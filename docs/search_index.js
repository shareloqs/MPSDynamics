var documenterSearchIndex = {"docs":
[{"location":"nutshell/#In-a-nutshell:-MPSDynamics.jl-for-open-quantum-systems","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"","category":"section"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"MPSDynamics.jl was originally developed to perform tensor network simulations of open quantum systems by solving the Schrödinger equation for the closed {System + Environment}.  The key idea to construct the simulations is to reformulate the open quantum system Hamiltonian as a one-dimensional many-body problem with nearest-neighbor interactions.  The dynamics are then efficiently simulated with Tensor Networks methods. ","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"(Image: Sketch of the different ingredients behind MPSDynamics)","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"The starting point is a system linearly coupled to a bosonic environment, where the coupling between system and environment is specified by the spectral density function J(omega): the prototypical example being The Spin-Boson Model. At finite temperature, the initial state of the environment will be a thermal state (mixed), requiring density matrix formalism and thus making the problem more complex. To circumvent this issue, we consider instead an extended environment, with coupling to the system characterized by a thermalized spectral density function J(omegabeta).  The two environments induce the same reduced dynamics on the system, enabling us to deal with pure states only[1]. The vacuum state (pure) of the extended environment corresponds to the thermal state of the original environment. ","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"To exploit the computational efficiency of the matrix product states (MPS) description of pure states, we apply the so called Chain-Mapping of bosonic environments —a unitary transformation dependent on J(omegabeta)— to the Spin-Boson Hamiltonian, mapping it on a chain Hamiltonian with nearest-neighbor interactions. This enables efficient representation of the full {System + Environment} state and its time evolution using the Time-Dependent Variational Principle.","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"To go further, you will find in this documentation:","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"a User Guide explaining how to use the package\nseveral examples illustrating different features of the package: adaptive time-evolution methods, Time-dependent Hamiltonian, or fermionic environments with The Anderson Impurity Model\na Theoretical Background covering the chain mapping procedure, flying over the basics of tensor networks, and summarizing the TDVP methods","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"If this package was useful in your work, do not forget Citation. And if you would like to get involved in its development, you can find out How to Contribute.","category":"page"},{"location":"nutshell/","page":"In a nutshell: MPSDynamics.jl for open quantum systems","title":"In a nutshell: MPSDynamics.jl for open quantum systems","text":"[1]: Moreover, the dynamics of the original environment can still be recovered, see Inspecting the bath by undoing the chain mapping","category":"page"},{"location":"user-guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Here we explain the different steps to perform a simulation.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Examples with detailed explanations can be found in Examples.","category":"page"},{"location":"user-guide/#Initial-State","page":"User Guide","title":"Initial State","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The initial many-body state of the {System + Environment} can be described easily as Matrix Product States (MPS) or Tree Tensor Networks (TTN) state (e.g. when a system is coupled to several environments).","category":"page"},{"location":"user-guide/#Matrix-Product-States","page":"User Guide","title":"Matrix Product States","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"A MPS can be initialized with several methods.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The productstatemps method enables  to instantiate arbitrary MPS of fixed uniform bond dimension with non-uniform physical dimensions. The individual states of the MPS sites can be provided by setting state to a list of column vectors.  Setting state=:Vacuum will produce an MPS in the vacuum state.  Setting state=:FullOccupy will produce an MPS in which each site is fully occupied. The gauge of the MPS can also be set using a keyword argument.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> ψ = unitcol(1,2) # system initial state\n\njulia> d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1 \n\njulia> cpars = chaincoeffs_ohmic(N, α, s) # chain coefficient for an Ohmic spectral density\n\njulia> H = spinbosonmpo(ω0, Δ, d, N, cpars)\n\njulia> A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ>|Vacuum>","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Alternatively, a chain with a specified number of excitation localised on one site, or delocalized accross several sites can be generated with MPSDynamics.chainmps.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Random MPS can also be generated with the randmps method.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For the case of fermionic states (which need to be anti-symmetrized), the MPSDynamics.electronkmps method generate an MPS for an electron with momentum k, and the MPSDynamics.electron2kmps generate an MPS with 2 electrons in k-states k1 and k2.","category":"page"},{"location":"user-guide/#Tree-Tensor-Networks","page":"User Guide","title":"Tree Tensor Networks","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Write a quick explanation of the how trees are structured: parents, child, nodes; and that most methods to initialize a MPS are overloaded for TreeNetwork. ","category":"page"},{"location":"user-guide/#Hamiltonian","page":"User Guide","title":"Hamiltonian","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In order to perform time evolution and have access to the dynamics of the many-body state a Hamiltonian needs to be specified in the form of a Matrix Product Operator (MPO) of as a tree tensor network. Either way, this can be done by using a Build-in Hamiltonian, Convert a MPO from ITensor, or creating a Tailored MPO.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In the context of Open Quantum Systems, custom chain coefficients for the environment can be generated for finite temperature simulations, and/or user provided spectral densities (SDs).","category":"page"},{"location":"user-guide/#Build-in-Hamiltonian","page":"User Guide","title":"Build-in Hamiltonian","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"MPSDynamics provides several topical Hamiltonians directly in the form of MPO or Tree Tensor Networks such as the Ising model MPSDynamics.isingmpo, the XYZ Hamiltonian MPSDynamics.xyzmpo, the Spin Boson Model MPSDynamics.spinbosonmpo, a spin coupled to two bosonic baths MPSDynamics.twobathspinmpo, nearest neighbour interactions Hamiltonian MPSDynamics.nearestneighbourmpo, the independent boson model MPSDynamics.ibmmpo, (non-)uniform tight-binding chain Hamiltonian MPSDynamics.tightbindingmpo.","category":"page"},{"location":"user-guide/#Convert-a-MPO-from-ITensor","page":"User Guide","title":"Convert a MPO from ITensor","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The method MPSDynamics.MPOtoVector converts an ITensors chain MPO into a form compatible with MPSDynamics.","category":"page"},{"location":"user-guide/#Tailored-MPO","page":"User Guide","title":"Tailored MPO","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"One can also construct MPO tailored to the problem one is interested in. MPOs are fundamentally a lists of rank-4 tensors such that the right bond dimension of the nth tensor must be equal to the left bond dimension of the n+1th tensor; and the dimension of the physical bonds of the nth tensor must be equal to the corresponding physical bond on the MPS.","category":"page"},{"location":"user-guide/#Finite-Temperature-and-Custom-SD","page":"User Guide","title":"Finite Temperature and Custom SD","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In the T-TEDOPA framework (see Theoretical Background for more details) finite temperature simulations are done with an effective pure state description of the system and the environment where the coupling coefficients (or the SD) is temperature-dependent.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The corresponding chain coefficients for an Ohmic or a user provided spectral density (that can thus in pratice be either at zero or finite temperature) are computed with the [chaincoeffs_finiteT](@ref). This method is based on the ORTHOPOL routines[Gautschi]","category":"page"},{"location":"user-guide/#Observables","page":"User Guide","title":"Observables","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"System and environment observables can be computed, as well as system-and-environment 'non-local' observables.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Observables that will be passed to MPSDynamics.runsim(@ref) to have their expectation value computated at each time step are defined with the OneSiteObservable and [TwoSiteObservable](@ref).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"One-site and two-site obsevables work similarly, they need to be given a name, an (pair of) operator(s) and the (list of) site(s) on which they are evaluated.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For instance one can calculated the average number of excitation in each of the N environmental modes","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"It is also possible to measure composite system/environment observables, for example","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"which measure the correlation between the spin in the x-direction and the displacement of the bath modes.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Purely environmental 'non-local' observables such as ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = TwoSiteObservable(\"bath coherence\", crea(d), anih(d), collect(2:N+1), collect(2:N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"that computes all the chain mode coherences langlehata_n^daggerhata_mrangle (and the chain mode occupation when n = m).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"We note that if one knows the coherences and populations of all the chain modes, it is then possible to reconstruct the populations of the normal mode environment.","category":"page"},{"location":"user-guide/#Time-Evolution","page":"User Guide","title":"Time-Evolution","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Simulation are performed when calling the MPSDynamics.runsim function where the time-evolution method should be specified.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The time-evolution methods currently implemented belong to the familly of Time-Dependent Variational Principle (TDVP). The central point of this method, in the modern tensor networks formulation, is that instead of solving the Schrödinger equation and then truncating the MPS representation of the quantum state, one can solve the equations of motion projected into a space of restricted bond dimension.  The major advantage of this method is that it naturally preserves the unitarity of the time evolution and conserves the energy (except in its two-site implementation). Three variants of TDVP are implemented in the MPSDynamics.jl package:","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"one-site TDVP (TDVP1): fixed bond dimension, preserves unitarity, conserves energy, scales as mathcalO(D^2 d^2 w^2 + D^3 dw + D^3 d^2 ) where D is the MPS (or TTN) bond dimension, d the local dimension, w the MPO bond dimension.\ntwo-site TDVP (TDVP2): adaptive bond dimension, breaks unitarity, scales as mathcalO(D^2d^3 w^2 + D^3 d^2 w + D^3 d^3 ).\nadaptive one-site TDVP (DTDVP): adaptive bond dimension, preserves unitarity, conserves energy.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Local one-site and two-site observables, as well as non-local two-site observables, can be efficiently computed for each time-step of the time-evolution with the three methods.","category":"page"},{"location":"user-guide/#One-site-TDVP","page":"User Guide","title":"One-site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"This implementation of the TDVP can be used for MPS and TTN. It performs one-site updates of the tensor network tensors while keeping the bond dimension fixed. Because no reduction of the dimensionality is performed (for instnce by throwing away some simgular values), it naturally preserves unitarity and hence conserves energy. The otherside of the coin is that simulation might be slower because the bond dimension is large at all time.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter of the simulation is thus the bond dimension D.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"This method can be used with in MPSDynamics.runsim with the key word argument method=:TDVP1.","category":"page"},{"location":"user-guide/#Two-Site-TDVP","page":"User Guide","title":"Two-Site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"This version of the TDVP evolves two-site tensors than can be split back into two individual site tensors by applying an SVD. The bond dimension between two neighbouring sites can then be truncated to any value  r by throwing away any singular values that fall below some threshold.  In this way, the MPS bond dimension will grow dynamically throughout the course of the evolution to capture entanglement, as and when it emerges. The truncation entails a loss of unitarity.  Indeed, for a nearest-neighbour Hamiltonian, applying the two-site projector will not entail a projection error, leading to a scheme that is almost identical to TEBD,wherein the error arises solely from the truncation. Furthermore, 2TDVP scales poorly with the local physical dimension, and is known to have issues with long-range interactions.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter is the threshold of the SVD.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"This method can be used with in MPSDynamics.runsim with the key word argument method=:TDVP2.","category":"page"},{"location":"user-guide/#Adaptive-One-Site-TDVP","page":"User Guide","title":"Adaptive One-Site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Ahead of any time evolution, one computes new bond dimensions of the MPS if the relative rate of change of the TDVP projection error with respect to the bond dimension is larger than a chosen precision p. Then, TDVP1 is performed, using projectors with sub-spaces expanded accordingly, to produce an MPS evolved by one time step with the new,increased, bond dimensions. This version is faster than TDVP1 due to the acceleration gained from having more optimised bond dimensions; the bond update step is cheap and so its cost should not normally outweigh this advantage. However, two things need to be noticed:","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"DTDVP can get stuck into local minima from the initial time. If the bond dimension does not change during the time-evolution, consider embeding your MPS in a larger manifold with mpsembed! before time-evolving it.\nFor models with analytical solutions that are MPS of a given bond dimension (such as the independent boson model), DTDVP can overshoot the analytical bond dimension because the relative rate of change of the projection error becomes dominated by random numerical fluctuations.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter is a threshold value p for the rate of change of the projection error with respect to the bond dimension.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"This method can be used with in MPSDynamics.runsim with the key word argument method=:DTDVP.","category":"page"},{"location":"user-guide/#Data-Storage","page":"User Guide","title":"Data Storage","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The data (i.e. observables time-series) is stored in the JLD format which is based on HDF5.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The HDF5 format is natively supported across many platforms and languages (e.g. Python, or Mathematica).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For the data to be saved to a file after a run, the keyword argument save=true needs to be used in runsim.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The directory where the data should be saved can be chosen by setting a path with the savedir keyword argument.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"A plot keyword argument can also be used to choose whether plots for 1D observables will be automatically generated and saved along with the data. ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Loading the data in Julia using the JLD.jl package will recover the full type information of the Julia variables that were stored.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> using JLD\n\njulia> dat = load(\"filename.jld\")\nDict{String, Any} with 2 entries:\n  \"parameters\" => Dict{String, Any}(\"tmax\"=>0.2, \"method\"=>:DTDVP, \"dt\"=>0.0005…\n  \"data\"       => Dict{String, Any}(\"bonddims\"=>[1 1 … 1 1; 1 2 … 2 2; … ; 1 1 …","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"If the data is loaded in an variable dat the structure is the folowing:","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"the parameters entry contains a dictionary where all the simulation parameters are stored\nthe data entry contains a dictionary where are stored simulation time, the observables and (whenever relevent) the bond dimension of the state at each time steps. ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> dat[\"parameters\"]\nDict{String, Any} with 11 entries:\n  \"tmax\"       => 0.2\n  \"method\"     => :DTDVP\n  \"dt\"         => 0.0005\n  \"name\"       => \"my model\"\n  \"Δ\"          => 0.0\n  \"β\"          => 0.0186854\n  \"N\"          => 300.0\n  \"d\"          => 15.0\n  \"unid\"       => \"Ovzm6\"\n  \"ω0\"         => 0.0\n  \"convparams\" => 0.0005\n\njulia> dat[\"data\"]\nDict{String, Any} with 6 entries:\n  \"bonddims\" => [1 1 … 1 1; 1 2 … 2 2; … ; 1 1 … 7 7; 1 1 … 1 1]\n  \"sx\"       => [1.0, 0.912818, 0.741759, 0.605797, 0.528792, 0.492497, 0.47976…\n  \"sz\"       => [0.0, 0.0871825, 0.25824, 0.394201, 0.471207, 0.507503, 0.52023…\n  \"nchain\"   => [0.0 0.23466 … 1.84319 1.76098; 0.0 0.00231507 … 0.83105 0.9033…\n  \"sy\"       => [0.0, -0.0133489, -0.0588887, -0.0858181, -0.0759996, -0.048539…\n  \"times\"    => [0.0, 0.0005, 0.001, 0.0015, 0.002, 0.0025, 0.003, 0.0035, 0.00…\n","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"[Gautschi]: Gautschi, W. Algorithm 726: ORTHPOL–a package of routines for generating orthogonal polynomials and Gauss-type quadrature rules. ACM Trans. Math. Softw. 20, 21–62 (1994).","category":"page"},{"location":"examples/timedep/#Time-dependent-Hamiltonian","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"","category":"section"},{"location":"examples/timedep/#Context","page":"Time-dependent Hamiltonian","title":"Context","text":"","category":"section"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"To simulate a drive or a laser pulse, a time-dependent Hamiltonian is often needed. Here we explain thanks to the script in MPSDynamics/examples/sbm_Htimedependent.jl how this type of Hamiltonian can be integrated within the method and applied on a wavefunction. We will take a Spin-Boson Model (SBM) Hamiltonian with an Ohmic spectral density. However, the time-dependency is not model specific and can be adapated for other models. For more information about the SBM, see the dedicated example. For this example, we simulate a drive of the form","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"        hatH_textdrive(t) = epsilon hatsigma_x sin(omega_textdrive t)","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"with epsilon = frac2 piT_textRabi the amplitude of the drive, T_textRabi the Rabi period, and omega_textdrive the frequency of the drive. The drive is set up to be on resonance with the two-level system.","category":"page"},{"location":"examples/timedep/#The-code","page":"Time-dependent Hamiltonian","title":"The code","text":"","category":"section"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"First we load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, and the LaTeXStrings.jl one to be able to use LaTeX in the plots. The function MPSDynamics.disp is also imported.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"using MPSDynamics, Plots, LaTeXStrings\n\nimport MPSDynamics: disp","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We then define variables for the physical parameters of the simulation. Among these, three are convergence parameters:","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes\nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"The variable Ndrive represents the site of the MPO where the operator of the time-dependent part acts. For this example, the two-level system is at the first site of the MPS. ","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 4 # number of Fock states of the chain modes\n\nN = 60 # length of the chain\n\nα = 0.005 # coupling strength\n\nΔ = 0.0 # tunneling \n\nω0 = 0.8 # TLS gap\n\ns = 1 # ohmicity\n\ncpars = chaincoeffs_ohmic(N, α, s) # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0\n\nTrabi = 30.0 # Rabi period of the drive\n\nϵ = 2*pi / Trabi # Intensity of the drive\n\nωdrive = ω0 # Frequency of the drive\n\nNdrive = 1 #Number of the site on which the drive is applied","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present only one-site implementation of TDVP that preserves the unitarity of the evolution:","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Logically the constant bond dimension of the MPS for TDVP1 is the respective convergence parameter.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 0.5 # time step\n\ntfinal = 100.0 # simulation time\n\nmethod = :TDVP1 # time-evolution method\n\nD = [6] # MPS bond dimension","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Using MPSDynamics.jl built-in methods we define the SBM MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"In this part, the time-dependent terms of the MPO are stored in a list. This enables to add these terms to the MPO elements at each timestep and avoid the calculation of an entire new MPO. This way is not cumbersome since it adds a matrix sum at each time step.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\ntimelist = collect(0:dt:tfinal)\nnumsteps = length(timelist)-1\n\nHt = [ϵ*sx*sin(ωdrive*tstep) for tstep in timelist] # Time-dependent Hamiltonian term\n\nH = spinbosonmpo(ω0, Δ, d, N, cpars) # MPO representation of the Hamiltonian\n\nψ = unitcol(2,2) # Initial down-z system state \n\nA = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ>|Vacuum>","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We then choose the observables that will be stored in the data and the MPSDynamics.runsim arguments.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\nob2 = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))\n\nob3 = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))\n","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"MPSDynamics.runsim is called to perform the dynamics. The argument timedep is set up to true and Ndrive and Htime are provided in the kwargs. ","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H;\n                name = \"Driving field on ohmic spin boson model\",\n                method = method,\n                obs = [ob1],\n                convobs = [ob1],\n                params = @LogParams(N, d, α, Δ, ω0, s),\n                convparams = D,\n                timedep = true, # the Hamiltonian is time dependent\n                Ndrive = Ndrive, # the first site of the MPS/MPO (i.e. the system) is concerned\n                Htime = Ht, # list of time-dependent terms\n                verbose = false,\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Eventually, the stored observables can be represented","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"\n#----------\n# Plots\n#----------\n\nplot(dat[\"data/times\"], dat[\"data/sz\"], label=\"Dmax = $(D...)\", xlabel=L\"t\",ylabel=L\"\\sigma_z\", title=\"\")","category":"page"},{"location":"dev/#Developers","page":"Developers","title":"Developers","text":"","category":"section"},{"location":"dev/#Simulation-Workflow","page":"Developers","title":"Simulation Workflow","text":"","category":"section"},{"location":"dev/","page":"Developers","title":"Developers","text":"(Image: Flowchart of the simulation workflow)","category":"page"},{"location":"dev/#How-to-Contribute","page":"Developers","title":"How to Contribute","text":"","category":"section"},{"location":"dev/","page":"Developers","title":"Developers","text":"Contributions are welcome! Don't hesitate to contact us if you","category":"page"},{"location":"dev/","page":"Developers","title":"Developers","text":"found a bug;\nhave a suggestion on how to improve the code and/or documentation;\nwould like to get involved in writing code and/or documentation.","category":"page"},{"location":"dev/","page":"Developers","title":"Developers","text":"You can contact us by raising an issue on Github, or by writing to one of the developers.","category":"page"},{"location":"methods/#List-of-all-methods","page":"Methods","title":"List of all methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [MPSDynamics]","category":"page"},{"location":"methods/#MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}","page":"Methods","title":"MPSDynamics.OneSiteObservable","text":"OneSiteObservable(name,op,sites)\n\nComputes the local expectation value of the one-site operator op on the specified sites. Used to define one-site observables that are obs and convobs parameters for the runsim function.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}","page":"Methods","title":"MPSDynamics.MPOtoVector","text":"MPOtoVector(mpo::MPO)\n\nConvert an ITensors chain MPO into a form compatible with MPSDynamics\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}","page":"Methods","title":"MPSDynamics.addchild!","text":"addchild!(tree::Tree, id::Int)\n\nAdd child to node id of tree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}","page":"Methods","title":"MPSDynamics.addchildren!","text":"addchildren!(tree::Tree, id::Int, n::Int)\n\nAdd n children to node id of tree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Int64}","page":"Methods","title":"MPSDynamics.apply1siteoperator!","text":"apply1siteoperator!(A, O, sites::Int)\n\nApply an operator O on the MPS A. O is acting on only one site ::Int. The resulting MPS A is the MPS modified by the operator O.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Vector{Int64}}","page":"Methods","title":"MPSDynamics.apply1siteoperator!","text":"apply1siteoperator!(A, O, sites::Vector{Int})\n\nApply an operator O on the MPS A. O is acting on several sites ::Vector{Int}. The resulting MPS A is the MPS modified by the operator O.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.applympo!-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.applympo!","text":"applympo!(A, H)\n\nApply an MPO H on the MPS A. H must have the same number of site than A. The resulting MPS A is the MPS modified by the mpo H.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chaincoeffs_finiteT","page":"Methods","title":"MPSDynamics.chaincoeffs_finiteT","text":"chaincoeffs_finiteT(nummodes, β, ohmic=true; α, s, J, ωc=1, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=true)\n\nGenerate chain coefficients ϵ_0ϵ_1t_0t_1c_0 for a harmonic bath at the inverse temperature β.\n\nBy default a Ohmic spectral density J(ω) = 2αω_c (fracωω_c)^s θ(ω-ω_c) is considered. Users can provide their own spectral density.\n\nArguments\n\nnummodes: Number of bath modes\nβ: inverse temperature\nohmic: true if the spectral density is Ohmic, false if the user provides its own spectral density\nα: Kondo parameter of the Ohmic spectral density \ns: ohmicity\nJ: user-provided spectral density. Should be a function f(x,i) where x is the frequency and i ∈ {1,...,mc} labels the intervals on which the SD is defined\nωc: the maximum frequency of the Ohmic spectral density\nmc: the number of component intervals\nmp: the number of points in the discrete part of the measure (mp=0 if there is none)\niq: a parameter to be set equal to 1, if the user provides his or her own quadrature routine, and different from 1 otherwise\nidelta: a parameter whose default value is 1, but is preferably set equal to 2, if iq=1 and the user provides Gauss-type quadrature routines\nprocedure: choice between the Stieltjes and the Lanczos procedure\nAB: component intervals\nMmax: maximum number of integration points\nsave: if true the coefficients are saved\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}","page":"Methods","title":"MPSDynamics.chaincoeffs_ohmic","text":"chaincoeffs_ohmic(N, α, s; ωc=1, soft=false)\n\nGenerate chain coefficients ϵ_0ϵ_1t_0t_1c_0 for an Harmonic bath at zero temperature with a power law spectral density given by:\n\nsoft cutoff: J(ω) = 2αω_c (fracωω_c)^s exp(-ωω_c) \n\nhard cutoff: J(ω) = 2αω_c (fracωω_c)^s θ(ω-ω_c)\n\nThe coefficients parameterise the chain Hamiltonian\n\nH = H_S + c_0 A_SB_0+sum_i=0^N-1t_i (b_i+1^dagger b_i +hc) + sum_i=0^N ϵ_ib_i^dagger b_i\n\nwhich is unitarily equivalent (before the truncation to N sites) to\n\nH = H_S + A_Sint_0^dωsqrtJ(ω)B_ω + int_0^dωωb_ω^dagger b_ω.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}","page":"Methods","title":"MPSDynamics.chainmps","text":"chainmps(N::Int, site::Int, numex::Int)\n\nGenerate an MPS with numex excitations on site\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}","page":"Methods","title":"MPSDynamics.chainmps","text":"chainmps(N::Int, sites::Vector{Int}, numex::Int)\n\nGenerate an MPS with numex excitations of an equal super-position over sites\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainprop-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.chainprop","text":"chainprop(t, cparams...)\n\nPropagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.correlatedenvironmentmpo-Tuple{Vector, Int64, Int64}","page":"Methods","title":"MPSDynamics.correlatedenvironmentmpo","text":"correlatedenvironmentmpo(R::Vector, Nm::Int, d::Int; chainparams, fnamecc::String, s=1, α=1, ωc=1, c_phonon=1, β=\"inf\", issoft=false)\n\nGenerate a MPO for a one-dimensional bosonic bath spatially correlated to a multi-component system \n\nH_B + H_int = int_-^+ dk ω_k b_k^dagger b_k + _j int_-^+dk sqrtJ(k)(A_j b_k e^i k R_j + hc).\n\nThe interactions between the system and the chain-mapped bath are long range, i.e. each site interacts with all the chain modes. The spectral density is assumed to be Ohmic J(ω) = 2αωc(ωωc)^s.\n\nArguments\n\nR: List of system's components positions\nNm: Number of chain modes. The actual number of mode will be doubled to account for the left and right moving excitations.\nd: Local Hilbert space dimension of the bath modes\nchainparams: chain parameters, of the form chainparams=ϵ_0ϵ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(ω) at any temperature.\nfnamecc: Path to a file containing pre-computed long-range coupling coefficient. If not provided, the coupling coefficients will be computed and stored.\ns: Ohmicity\nα: Kondo parameter\nωc: Bath cut-off frequency\nc_phonon: Speed of sound in the bath\nβ: Inverse temperature \nissoft: Is the cut-off of the Ohmic SD soft or hard?\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.displacedchainmps-Tuple{Vector{Any}, Int64, Int64, Any}","page":"Methods","title":"MPSDynamics.displacedchainmps","text":"displacedchainmps(A::Vector{Any}, N::Int, Nm::Int, γ::Any)\n\nGiven a mps A, return a mps B where the `Nm`-long chain is displaced by `γ` without displacing the `N`-long system.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.dynamap-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.dynamap","text":"dynamap(ps1,ps2,ps3,ps4)\n\nCalulate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.electron2kmps","page":"Methods","title":"MPSDynamics.electron2kmps","text":"electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with 2 electrons in k-states k1 and k2.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.electronkmps","page":"Methods","title":"MPSDynamics.electronkmps","text":"electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS for an electron with momentum k.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.elementmpo","text":"elementmpo(M, el...)\n\nReturn the element of the MPO M for the set of physical states el...\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.elementmps","text":"elementmps(A, el...)\n\nReturn the element of the MPS A for the set of physical states el...\n\nExamples\n\njulia> A = chainmps(6, [2,4], 1);\n\njulia> elementmps(A, 1, 2, 1, 1, 1, 1)\n0.7071067811865475\n\njulia> elementmps(A, 1, 1, 1, 2, 1, 1)\n0.7071067811865475\n\njulia> elementmps(A, 1, 2, 1, 2, 1, 1)\n0.0\n\njulia> elementmps(A, 1, 1, 1, 1, 1, 1)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.entanglemententropy-Tuple{Any}","page":"Methods","title":"MPSDynamics.entanglemententropy","text":"entanglemententropy(A)\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.findchainlength-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.findchainlength","text":"findchainlength(T, cparams...; eps=10^-6)\n\nEstimate length of chain required for a particular set of chain parameters by calculating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T. The initial number of sites in cparams has to be larger than the findchainlength result.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}","page":"Methods","title":"MPSDynamics.findchild","text":"findchild(node::TreeNode, id::Int)\n\nReturn integer corresponding to the which number child site id is of node.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.gauss-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.gauss","text":"GAUSS Gauss quadrature rule.\n\nGiven a weight function w encoded by the nx2 array ab of the\nfirst n recurrence coefficients for the associated orthogonal\npolynomials, the first column of ab containing the n alpha-\ncoefficients and the second column the n beta-coefficients,\nthe call xw = GAUSS(n,ab) generates the nodes and weights xw of\nthe n-point Gauss quadrature rule for the weight function w.\nThe nodes, in increasing order, are stored in the first\ncolumn, the n corresponding weights in the second column, of\nthe nx2 array xw.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.hbathchain","text":"hbathchain(N::Int, d::Int, chainparams, longrangecc...; tree=false, reverse=false, coupletox=false)\n\nGenerate MPO representing a tight-binding chain of N oscillators with d Fock states each. Chain parameters are supplied in the standard form: chainparams =ϵ_0ϵ_1t_0t_1c_0. The output does not itself represent a complete MPO but will possess an end which is open and should be attached to another tensor site, usually representing the system.\n\nArguments\n\nreverse: If reverse=true create a chain were the last (i.e. Nth) site is the site which couples to the system\ncoupletox: Used to choose the form of the system coupling. coupletox=true gives a non-number conserving coupling of the form H_textI= A_textS(b_0^dagger + b_0) where A_textS is a system operator, while coupletox=false gives the number-converving coupling H_textI=(A_textS b_0^dagger + A_textS^dagger b_0)\ntree: If true the resulting chain will be of type TreeNetwork; useful for construcing tree-MPOs \n\nExample\n\nOne can constuct a system site tensor to couple to a chain by using the function up to populate the tensor. For example, to construct a system site with Hamiltonian Hs and coupling operator As, the system tensor M is constructed as follows for a non-number conserving interaction:\n\nu = one(Hs) # system identity\nM = zeros(1,3,2,2)\nM[1, :, :, :] = up(Hs, As, u)\n\nThe full MPO can then be constructed with:\n\nHmpo = [M, hbathchain(N, d, chainparams, coupletox=true)...]\n\nSimilarly for a number conserving interaction the site tensor would look like:\n\nu = one(Hs) # system identity\nM = zeros(1,4,2,2)\nM[1, :, :, :] = up(Hs, As, As', u)\n\nAnd the full MPO would be\n\nHmpo = [M, hbathchain(N, d, chainparams; coupletox=false)...]\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.heisenbergmpo","page":"Methods","title":"MPSDynamics.heisenbergmpo","text":"heisenbergmpo(N::Int, J=1.0) = xyzmpo(N; Jx=J)\n\nGenerate MPO for the N-spin Heisenberg XXX model, defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J σ_x^n σ_x^n+1 - J σ_y^n σ_y^n+1 - J σ_z^n σ_z^n+1\n\nwith σ_x^n σ_y^n σ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.ibmmpo-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.ibmmpo","text":"ibmmpo(ω0, d, N, chainparams; tree=false)\n\nGenerate MPO for a spin-1/2 coupled to a chain of harmonic oscillators with the interacting boson model (IBM), defined by the Hamiltonian\n\nH = fracω_02σ_z +  c_0σ_z(b_0^dagger+b_0) + sum_i=0^N-1 t_i (b_i+1^dagger b_i +hc) + sum_i=0^N ϵ_ib_i^dagger b_i.\n\nThe spin is on site 1 of the MPS and the bath modes are to the right.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracω_02σ_z + σ_zint_0^ dωsqrtfracJ(ω)π(b_ω^dagger+b_ω) + int_0^ dω ωb_ω^dagger b_ω.\n\nThe chain parameters, supplied by chainparams=ϵ_0ϵ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(ω) at any temperature.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.isingmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.isingmpo","text":"isingmpo(N; J=1.0, h=1.0)\n\nGenerate MPO for the N-spin 1D Ising model with external field vech = (00h), defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J_x σ_x^n σ_x^n+1 + sum_n=1^N(- h_z σ_z^n)\n\nwith σ_x^n σ_y^n σ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.lanczos-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.lanczos","text":"LANCZOS Lanczos algorithm.\n\nGiven the discrete inner product whose nodes are contained\nin the first column, and whose weights are contained in the\nsecond column, of the nx2 array xw, the call ab=LANCZOS(n,xw)\ngenerates the first n recurrence coefficients ab of the\ncorresponding discrete orthogonal polynomials. The n alpha-\ncoefficients are stored in the first column, the n beta-\ncoefficients in the second column, of the nx2 array ab.\n\nThe script is adapted from the routine RKPW in\nW.B. Gragg and W.J. Harrod, ``The numerically stable\nreconstruction of Jacobi matrices from spectral data'',\nNumer. Math. 44 (1984), 317-335.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.longrange_isingmpo","page":"Methods","title":"MPSDynamics.longrange_isingmpo","text":"longrange_isingmpo(N::Int, α::Float64=0.; J=1.0, h=1.0) = longrange_xyzmpo(N, α; Jx=J, Jy=0., Jz=0., hz=h, hx=0.)\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.longrange_xyzmpo","page":"Methods","title":"MPSDynamics.longrange_xyzmpo","text":"longrange_xyzmpo(N::Int, α::Float64=0.; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)\n\nGennerate MPO for the N-spin long-range XYZ model with external field vech=(h_x 0 h_z), , defined by the Hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.measure-Tuple{Any, OneSiteObservable}","page":"Methods","title":"MPSDynamics.measure","text":"measure(A, O; kwargs...)\n\nMeasure observable O on mps state A\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}","page":"Methods","title":"MPSDynamics.measure1siteoperator","text":"measure1siteoperator(A::Vector, O, sites::Vector{Int})\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if it is specified.\n\nFor calculating operators on single sites this will be more efficient if the site is on the left of the mps.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure1siteoperator-Tuple{Vector, Any}","page":"Methods","title":"MPSDynamics.measure1siteoperator","text":"measure1siteoperator(A::Vector, O)\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}","page":"Methods","title":"MPSDynamics.measure2siteoperator","text":" measure2siteoperator(A::Vector, M1, M2, j1, j2)\n\nCaculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.modemps","page":"Methods","title":"MPSDynamics.modemps","text":"modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with numex excitations of an equal superposition of modes k of a bosonic tight-binding chain.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.modemps-2","page":"Methods","title":"MPSDynamics.modemps","text":"modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with numex excitations of mode k of a bosonic tight-binding chain. \n\nchainparams takes the form [e::Vector, t::Vector] where e are the on-site energies and t are the hoppping parameters.\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsembed!-Tuple{Vector, Int64}","page":"Methods","title":"MPSDynamics.mpsembed!","text":"mpsembed(A::Vector, Dmax::Int)\n\nEmbed MPS A in manifold of max bond-dimension Dmax\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsleftnorm!","page":"Methods","title":"MPSDynamics.mpsleftnorm!","text":"mpsleftnorm!(A::Vector, jq::Int=length(A))\n\nLeft orthoganalise MPS A up to site jq.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsmixednorm!","text":"mpsmixednorm!(A::TreeNetwork, id::Int)\n\nNormalise tree-MPS A such that orthogonality centre is on site id.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}","page":"Methods","title":"MPSDynamics.mpsmixednorm!","text":"mpsmixednorm!(A::Vector, OC::Int)\n\nPut MPS A into mixed canonical form with orthogonality centre on site OC.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsmoveoc!","text":"mpsmoveoc!(A::TreeNetwork, id::Int)\n\nMove the orthogonality centre of right normalised tree-MPS A to site id.\n\nThis function will be more efficient than using mpsmixednorm! if the tree-MPS is already right-normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsrightnorm!","page":"Methods","title":"MPSDynamics.mpsrightnorm!","text":"mpsrightnorm!(A::Vector, jq::Int=1)\n\nRight orthoganalise MPS A up to site jq.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}","page":"Methods","title":"MPSDynamics.mpsrightnorm!","text":"mpsrightnorm!(A::TreeNetwork)\n\nWhen applied to a tree-MPS, right normalise towards head-node.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsshiftoc!","text":"mpsshiftoc!(A::TreeNetwork, newhd::Int)\n\nShift the orthogonality centre by one site, setting new head-node newhd.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.multiply-Tuple{Vector, Vector}","page":"Methods","title":"MPSDynamics.multiply","text":"multiply(M1::Vector, M2::Vector)\n\nCalculates M1*M2 where M1 and M2 are MPOs\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.nearestneighbourmpo","page":"Methods","title":"MPSDynamics.nearestneighbourmpo","text":"nearestneighbourmpo(N::Int, h0, A, Ad = A')\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.nearestneighbourmpo-2","page":"Methods","title":"MPSDynamics.nearestneighbourmpo","text":"nearestneighbourmpo(tree_::Tree, h0, A, Ad = A')\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}","page":"Methods","title":"MPSDynamics.normmps","text":"normmps(net::TreeNetwork; mpsorthog=:None)\n\nWhen applied to a tree-MPS mpsorthog=:Left is not defined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.normmps-Tuple{Vector}","page":"Methods","title":"MPSDynamics.normmps","text":"normmps(A::Vector; mpsorthog=:None)\n\nCalculate norm of MPS A.\n\nSetting mpsorthog=:Right/:Left will calculate the norm assuming right/left canonical form. Setting mpsorthog=OC::Int will cause the norm to be calculated assuming the orthoganility center is on site OC. If mpsorthog is :None the norm will be calculated as an MPS-MPS product.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.orthcentersmps-Tuple{Vector}","page":"Methods","title":"MPSDynamics.orthcentersmps","text":"orthcentersmps(A)\n\nCompute the orthoganality centres of MPS A.\n\nReturn value is a list in which each element is the corresponding site tensor of A with the orthoganility centre on that site. Assumes A is right normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.physdims-Tuple{Vector}","page":"Methods","title":"MPSDynamics.physdims","text":"physdims(M)\n\nReturn the physical dimensions of an MPS or MPO M.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.productstatemps","page":"Methods","title":"MPSDynamics.productstatemps","text":"productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)\n\nReturn an MPS representing a product state with local Hilbert space dimensions given by physdims.\n\nBy default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, Dmax can be set accordingly.\n\nThe indvidual states of the MPS sites can be provided by setting state to a list of column vectors. Setting state=:Vacuum will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting state=:FullOccupy will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).\n\nThe argument mpsorthog can be used to set the gauge of the resulting MPS.\n\nExample\n\njulia> ψ = unitcol(1,2); d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1\n\njulia> cpars = chaincoeffs_ohmic(N, α, s)\n\njulia> H = spinbosonmpo(ω0, Δ, d, N, cpars)\n\njulia> A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ>|Vacuum>\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.productstatemps-2","page":"Methods","title":"MPSDynamics.productstatemps","text":"productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)\n\nReturn an N-site MPS with all local Hilbert space dimensions given by d. \n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.protontransfermpo-NTuple{11, Any}","page":"Methods","title":"MPSDynamics.protontransfermpo","text":"protontransfermpo(ω0e,ω0k,x0e,x0k, Δ, dRC, d, N, chainparams, RCparams, λreorg)\n\nGenerate a MPO for a system described in space with a reaction coordinate (RC) tensor. The RC tensor is coupled to a bosonic bath, taking into account the induced reorganization energy. \n\nH_S + H_RC + H_int^S-RC = omega^0_e erangle langle e + omega^0_k krangle langle k + Delta (erangle langle k + krangle langle e) + omega_RC (d^daggerd + frac12) + g_e erangle langle e( d + d^dagger)+ g_k k rangle langle k( d + d^dagger) H_B + H_int^RC-B = int_-^+ dk ω_k b_k^dagger b_k - (d + d^dagger)int_0^ dωsqrtJ(ω)(b_ω^dagger+b_ω) + lambda_reorg(d + d^dagger)^2. lambda_reorg = int fracJ(omega)omegadomega.\n\nArguments\n\nω0e: enol energy at x=0 \nω0k: keto energy at x=0\nx0e: enol equilibrium displacement\nx0k: keto equilibrium displacement \nΔ: direct coupling between enol and keto\ndRC: fock space of the RC tensor \nd: number of Fock states of the chain modes\nN: length of the chain\nchainparams: chain parameters, of the form chainparams=ϵ_0ϵ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(ω) at any temperature. \nRCparams: RC tensor parameter, of the form RCparams=ωRC-gx \nλreorg: reorganization energy\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.puredephasingmpo-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.puredephasingmpo","text":"puredephasingmpo(ΔE, dchain, Nchain, chainparams; tree=false)\n\nGenerate MPO for a pure dephasing model, defined by the Hamiltonian\n``H = \\frac{ΔE}{2} σ_z +  \\frac{σ_z}{2} c_0 (b_0^\\dagger + b_0) + \\sum_{i=0}^{N-1} t_i (b_{i+1}^\\dagger b_i +h.c.) + \\sum_{i=0}^{N-1} ϵ_i b_i^\\dagger b_i  ``\n\nThe spin is on site 1 of the MPS and the bath modes are to the right.\n\n### Arguments\n* `ΔE::Real`: energy splitting of the spin\n* `dchain::Int`: physical dimension of the chain sites truncated Hilbert spaces\n* `Nchain::Int`: number of sites in the chain\n* `chainparams::Array{Real,1}`: chain parameters for the bath chain. The chain parameters are given in the standard form: `chainparams` ``=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]``.\n* `tree::Bool`: if true, return a `TreeNetwork` object, otherwise return a vector of MPO tensors\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.randisometry-Tuple{Type, Int64, Int64}","page":"Methods","title":"MPSDynamics.randisometry","text":"randisometry([T=Float64], dims...)\n\nConstruct a random isometry\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.randmps","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(N::Int, d::Int, Dmax::Int, T=Float64)\n\nConstruct a random, N-site, right-normalised MPS with all local Hilbert space dimensions given by d.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.randmps-2","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(tree::Tree, physdims, Dmax::Int, T::Type{<:Number} = Float64)\n\nConstruct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by Dmax.\n\nThe local Hilbert space dimensions are specified by physdims which can either be of type Dims{length(tree)}, specifying the dimension of each site, or of type Int, in which case the same local dimension is used for every site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Int64}, Tuple{Tuple{Vararg{Int64, N}}, Int64, Type{<:Number}}} where N","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(physdims::Dims{N}, Dmax::Int, T::Type{<:Number} = Float64) where {N}\n\nConstruct a random, right-normalised MPS with local Hilbert space dimensions given by physdims and max bond-dimension given by Dmax. \n\nT specifies the element type, eg. use T=ComplexF64 for a complex valued MPS.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.randtree-Tuple{Int64, Int64}","page":"Methods","title":"MPSDynamics.randtree","text":"randtree(numnodes::Int, maxdegree::Int)\n\nConstruct a random tree with nummodes modes and max degree maxdegree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.readchaincoeffs","text":"readchaincoeffs(fdir, params...)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.rmsd-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.rmsd","text":"rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})\n\nCalculate the root mean squared difference between two measurements of an observable over the same time period.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.runsim-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.runsim","text":"runsim(dt, tmax, A, H; \n\tmethod=:TDVP1, \n\tmachine=LocalMachine(), \n\tparams=[], \n\tobs=[], \n\tconvobs=[],\n            convparams=error(\"Must specify convergence parameters\"),\n            save=false,\n            plot=save,\n            savedir=string(homedir(),\"/MPSDynamics/\"),\n            unid=randstring(5),\n            name=nothing,\n\tkwargs...\n\t)\n\nPropagate the MPS A with the MPO H up to time tmax in time steps of dt. The final MPS is returned to A and the measurement data is returned to dat \n\nArguments\n\nmethod: Several methods are implemented in MPSDynamics. :TDVP1 refers to 1-site TDVP on tree and chain MPS, :TDVP2 refers to 2-site TDVP on chain MPS, :DTDVP refers to a variant of 1-site TDVP with dynamics bond-dimensions on chain MPS\nmachine: LocalMachine() points local ressources, RemoteMachine() points distant ressources\nparams: list of parameters written in the log.txt file to describe the dynamics. Can be listed with @LogParams(). \nobs: list of observables that will be measured at every time step for the most accurate convergence parameter supplied to convparams \nconvobs: list of observables that will be measure at every time step for every convergence parameter supplied to convparams \nconvparams: list of convergence parameter with which the propagation will be calculated for every parameter. At each parameter, convobs are measured while obs are measured only for the most accurate dynamics\nsave: Used to choose whether the data will also be saved to a file  \nplot: Used to choose whether plots for 1D observables will be automatically generated and saved along with the data\nsavedir: Used to specify the path where resulting files are stored\nunid: Used to specify the name of the directory containing the resulting files\nname: Used to describe the calculation. This name will appear in the log.txt file\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.spinbosonmpo-NTuple{5, Any}","page":"Methods","title":"MPSDynamics.spinbosonmpo","text":"spinbosonmpo(ω0, Δ, d, N, chainparams; rwa=false, tree=false)\n\nGenerate MPO for a spin-1/2 coupled to a chain of harmonic oscillators, defined by the Hamiltonian\n\nH = fracω_02σ_z + Δσ_x + c_0σ_x(b_0^dagger+b_0) + sum_i=0^N-1 t_i (b_i+1^dagger b_i +hc) + sum_i=0^N ϵ_ib_i^dagger b_i.\n\nThe spin is on site 1 of the MPS and the bath modes are to the right.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracω_02σ_z + Δσ_x + σ_xint_0^ dωsqrtJ(ω)(b_ω^dagger+b_ω) + int_0^ dω ωb_ω^dagger b_ω.\n\nThe chain parameters, supplied by chainparams=ϵ_0ϵ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(ω) at any temperature.\n\nThe rotating wave approximation can be made by setting rwa=true.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.spinchainmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.spinchainmpo","text":"spinchainmpo(N::Int; J=1.0, hz=1.0, hx=0.0, i=div(N,2))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.stieltjes-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.stieltjes","text":"STIELTJES Discretized Stieltjes procedure.\n\nGiven the discrete inner product whose nodes are contained\nin the first column, and whose weights are contained in the\nsecond column, of the nx2 array xw, the call ab=STIELTJES(n,xw)\ngenerates the first n recurrence coefficients ab of the\ncorresponding discrete orthogonal polynomials. The n alpha-\ncoefficients are stored in the first column, the n beta-\ncoefficients in the second column, of the nx2 array ab.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.svdmps-Tuple{Any}","page":"Methods","title":"MPSDynamics.svdmps","text":"svdmps(A)\n\nFor a right normalised mps A compute the full svd spectrum for a bipartition at every bond.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.svdtrunc-Tuple{Any}","page":"Methods","title":"MPSDynamics.svdtrunc","text":"U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)\n\nPerform a truncated SVD, with maximum number of singular values to keep equal to truncdim or truncating any singular values smaller than truncerr. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tightbinding_mpo-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.tightbinding_mpo","text":"tightbinding_mpo(N, ϵd, chainparams1, chainparams2)\n\nGenerate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well) \nof energy ϵd at the center. The impurity is coupled to two leads, each described by a set of chain parameters.\nThe interactions are nearest-neighbour, with the first N/2-1 sites corresponding to the first lead,\nthe Nth site corresponding to the impurity, and the rest of the sites corresponding to the second\nlead.\n\n# Arguments\n\n* `N::Int`: number of sites in the chain\n* `ϵd::Real`: energy of the impurity site at the center, as Ed - μ, where μ is the chemical potential\n* chainparams1::Array{Real,1}: chain parameters for the first lead\n* chainparams2::Array{Real,1}: chain parameters for the second lead\n\nThe chain parameters are given in the standard form: `chainparams` ``=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]``.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}","page":"Methods","title":"MPSDynamics.tightbindingmpo","text":"tightbindingmpo(N::Int, d::Int; J=1.0, e=1.0)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}","page":"Methods","title":"MPSDynamics.tunnelingmpo","text":"tunnelingmpo(ϵ, delta, α, s, β, d::Int, nummodes::Int; tree=false, ωc=1)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.twobathspinmpo","page":"Methods","title":"MPSDynamics.twobathspinmpo","text":"twobathspinmpo(ω0, Δ, Nl, Nr, dl, dr, chainparamsl=[fill(1.0,N),fill(1.0,N-1), 1.0], chainparamsr=chainparamsl; tree=false)\n\nGenerate MPO for a spin-1/2 coupled to two chains of harmonic oscillators, defined by the Hamiltonian\n\nH = fracω_02σ_z + Δσ_x + c_0^rσ_x(b_0^dagger+b_0) + sum_i=0^N_r-1 t_i^r (b_i+1^dagger b_i +hc) + sum_i=0^N_r ϵ_i^rb_i^dagger b_i + c_0^lσ_x(d_0^dagger+d_0) + sum_i=0^N_l-1 t_i^l (d_i+1^dagger d_i +hc) + sum_i=0^N_l ϵ_i^l d_i^dagger d_i.\n\nThe spin is on site N_l + 1 of the MPS, surrounded by the left chain modes and the right chain modes.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracω_02σ_z + Δσ_x + σ_xint_0^ dωsqrtfracJ(ω)π(b_ω^dagger+b_ω) + int_0^ dω ωb_ω^dagger b_ωi + σ_xint_0^ dωsqrtfracJ^l(ω)π(d_ω^dagger+d_ω) + int_0^ dω ωd_ω^dagger d_ω.\n\nThe chain parameters, supplied by chainparams=ϵ_0ϵ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(ω) at any temperature. The two chains can have a different spectral density.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.xxzmpo","page":"Methods","title":"MPSDynamics.xxzmpo","text":"xxzmpo(N::Int, Δ = 1.0, J=1.0) = xyzmpo(N; Jx=J, Jy=J, Jz=J*Δ)\n\nGenerate MPO for the N-spin XXZ model, defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J σ_x^n σ_x^n+1 - J σ_y^n σ_y^n+1 - Delta J σ_z^n σ_z^n+1\n\nwith σ_x^n σ_y^n σ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.xyzmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.xyzmpo","text":"xyzmpo(N::Int; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)\n\nGenerate MPO for the N-spin XYZ model with external field vech=(h_x 0 h_z), , defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J_x σ_x^n σ_x^n+1 - J_y σ_y^n σ_y^n+1 - J_z σ_z^n σ_z^n+1 + sum_n=1^N(- h_x σ_x^n - h_z σ_z^n)\n\nwith σ_x^n σ_y^n σ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"method"},{"location":"convergence/#Convergence-checks","page":"Convergence checks","title":"Convergence checks","text":"","category":"section"},{"location":"convergence/","page":"Convergence checks","title":"Convergence checks","text":"In this section, we analyze the numerical accuracy of our simulations by outlining the necessary approximations and providing practical guidelines to ensure convergence of results.","category":"page"},{"location":"convergence/#Chain-length-N","page":"Convergence checks","title":"Chain length N","text":"","category":"section"},{"location":"convergence/","page":"Convergence checks","title":"Convergence checks","text":"During a numerical simulation, a truncation on the number of chain modes (and therefore chain length) will be introduced, in order to work with a chain of finite length instead of a semi-infinite one. This truncation on chain modes, let us say N, introduces a sampling on the modes in the original environment. ","category":"page"},{"location":"convergence/#Local-dimension-d","page":"Convergence checks","title":"Local dimension d","text":"","category":"section"},{"location":"convergence/","page":"Convergence checks","title":"Convergence checks","text":"Another critical truncation is imposed on the local dimension d of each tensor in the MPS that undergoes dynamic evolution. The local dimension dd corresponds to the number of Fock states retained in the Hilbert space of each chain mode. Since harmonic oscillators are, in principle, infinite-dimensional systems, truncating their Hilbert space to a finite d is necessary for numerical computations. The choice of dd determines the maximum number of excitations per site in the MPS and must be carefully tuned to capture the relevant physics while ensuring numerical convergence.","category":"page"},{"location":"theory/#Theoretical-Background","page":"Theoretical Background","title":"Theoretical Background","text":"","category":"section"},{"location":"theory/#Chain-Mapping-of-bosonic-environments","page":"Theoretical Background","title":"Chain-Mapping of bosonic environments","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"We consider, in the Schrödinger picture, a general Hamiltonian where a non-specified system interacts linearly with a bosonic environments","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"beginaligned\n    hatH = hatH_S + int_0^+infty hbaromegahata^dagger_omegahata_omega mathrmdomega + hatA_Sint_0^+inftysqrtJ(omega)left(hata_omega + hata^dagger_omegaright)mathrmdomega\nendaligned","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where hat a_omega (hat a^dagger_omega) is a bosonic annihilation (creation) operator for a normal mode of the environment of energy hbaromega, hatA_S is a system operator, and J(omega) = sum_k g_k^2delta(omega - omega_k) is the bath spectral density (SD), defined with the microscopic system-environment coupling strength g_k. The SD quantifies the coupling strengths of the different normal modes of the environment with the system. Any SD that is not flat corresponds to a non-Markovian environment.","category":"page"},{"location":"theory/#Zero-Temperature","page":"Theoretical Background","title":"Zero Temperature","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Let us consider the Hamiltonian presented in Eq.(1). To investigate its rich phenomenology, using the powerful tools provided by tensor network techniques, it is convenient to map the system and its environment from a star-like to a chain-like configuration, with local interactions. To do so, we introduce a unitary transformation of the continuous normal modes hata_omega to an infinite discrete set of interacting modes hatb_n[chin_exact_2010].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hata_omega = sum_n=0^+infty U_n(omega)hatb_n = sum_n=0^+infty sqrtJ(omega)P_n(omega)hatb_n ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where P_n(omega) are orthonormal polynomials such that","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    int_0^+inftyP_n(omega)P_m(omega)J(omega)mathrmdomega = delta_nm ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"and the inverse transformation is","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatb_n = int_0^+infty U_n(omega)hata_omegamathrmdomega ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Note that the orthonormality of the polynomials ensures the unitarity of the transformation defined in Eq.(2). The mapping from a continuous set of modes to a (still infinite) discrete set might seem counter-intuitive, however it is a direct consequence of the separability of the underlying Hilbert space.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Under this transformation, the Hamiltonian in Eq.(1) becomes","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatH= hatH_S + sum_n=0^+inftyvarepsilon_nhatb_n^daggerhatb_n + t_n(hatb_n+1^daggerhatb_n + mathrmhc) + kappahatA_S(hatb_0 + hatb_0^dagger) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Hence, this mapping transforms the normal bath Hamiltonian into a tight-binding Hamiltonian with on-site energies varepsilon_n and hopping energies t_n. Another important consequence of this mapping is that now the system only interacts with the first mode n = 0 of the chain-mapped environment. The chain coefficients varepsilon_n, t_n, and the coupling kappa depend solely on the SD.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This makes chain mapping a tool of choice for describing systems coupled to environment with highly structured SD (e.g. experimentally measured or calculated ab initio)[chin_role_2013][alvertis_nonequilibrium_2019][dunnett_influence_2021][caycedosoler_exact_2022]. In this new representation, the Hamiltonian in Eq.(5) has naturally a 1D chain topology. This makes its representation as a Matrix Product Operator (MPO) and the representation of the joint {System + Environment} wave-function as a Matrix Product State (MPS) suited [orus_practical_2014][paeckel_timeevolution_2019].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The orthogonal polynomial-based chain mapping and the subsequent representation of the joint wave-function as a MPS (and the operators as MPO) are the building blocks of the Time-dependent Density operator with Orthonormal Polynomials Algorithm (TEDOPA) one of the state-of-the-art numerically exact method to simulate the dynamics of open quantum systems especially in the non-Markovian, non-perturbative regimes both at zero and finite temperatures [prior_efficient_2010][woods_simulating_2015][tamascelli_efficient_2019][dunnett_simulating_2021][lacroix_unveiling_2021].","category":"page"},{"location":"theory/#Finite-Temperature-with-T-TEDOPA","page":"Theoretical Background","title":"Finite Temperature with T-TEDOPA","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Assuming a unitary evolution for both the system and environment, the system's dynamics can be isolated by tracing out the environmental degrees of freedom. The density operator for the system at time t is described as","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatrho_S(t) = textTr_ElefthatU(t) hatrho_S(0) otimes hatrho_E(0) hatU^dagger(t)right","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Initially, the system state, hatrho_S(0), can be pure or mixed, and the environment is in a thermal state defined by the inverse temperature beta = (k_B T)^-1. This state is represented by a product of Gaussian states","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatrho_E(0) = bigotimes_omega frace^-beta omega hata_omega^dagger hata_omegaZ_omega(beta) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The system's evolution is dictated by the environment's two-time correlation function S(t), which in turn is determined by the spectral density function J and the temperature beta via the Bose-Einstein distribution n_omega(beta)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"S(t) = int_0^infty domega J(omega)lefte^-iomega t(1 + n_omega(beta)) + e^iomega t n_omega(beta)right ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"To simulate finite temperature effects using a zero-temperature model with the T-TEDOPA method [tamascelli_efficient_2019], we extend the spectral density function to cover both positive and negative frequencies, allowing us to use a pure state description for the environment. This is achieved by defining a new spectral density function J(omega beta) that incorporates the Boltzmann factors, supporting the entire real axis","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"J(omega beta) = fractextsign(omega)J(leftomegaright)2 Big(1 + cothBig(fracbeta omega2Big)Big)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This modified bath has the same correlation function S(t) and thus allows us to maintain a pure state description of the environment, represented as a vacuum state, and avoid the computational complexities of density matrices","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"lefttextvacrightrangle = bigotimes_omega left0_omegarightrangle ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The Hamiltonian of the system interacting with this extended bath now includes temperature-dependent interactions:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatH = hatH_S + int_-infty^+infty domega omega hata_omega^dagger hata_omega + hatA_S otimes int_-infty^+infty domega sqrtJ(omegabeta)left(hata_omega^dagger+hata_omegaright)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This method simplifies the simulation of finite temperature effects by treating them within an effective zero-temperature framework, thereby keeping the computational advantages of using pure states. In conclusion: the dynamics of the system resulting from the interaction with the original bath, starting in a thermal state at finite temperature, is exactly the same as the one resulting from the interaction with the extended environment, starting in the vacuum state at zero temperature. Once computed the chain coefficients at a given inverse temperature beta, the time evolution of the vacuum state interacting with the extended environment can be efficiently simulated using MPS time evolution methods.","category":"page"},{"location":"theory/#Finite-temperature-with-the-thermofield-transformation","page":"Theoretical Background","title":"Finite temperature with the thermofield transformation","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Finite temperature initial states of the system are challenging: in the previous section we have seen that a very efficient solution is to reabsorb the effect of the temperature inside of the spectral density function that characterizes the environment. De Vega and Bañuls present[devega_thermo_2015] another suggestive approach based on the idea of the thermofield transformation. The idea is to double the environmental degrees of freedom and then to apply a Bogoliubov transformation: the real environment in a thermal state is transformed into two virtual environments in the vacuum state, defined as the thermofield vacuum. For any operator of the real environment, the expectation values in the thermal state are equivalent to those calculated in the thermofield vacuum. Behind the thermofield approach there is the concept of purification: the initial mixed state of the environment can be represented as the partial trace of a pure state (the thermofield vacuum) defined on the larger Hilbert space of the modes of the two virtual environments at zero temperature. The interaction of the system and each one of the two environments is then mapped on two separate chains, using the TEDOPA chain mapping to define a unitary transformation that can be applied to the bath modes, in order to define new modes for the environment, mapping it from a star-like to a one dimensional chain-like configuration, which is very well suited for the application of tensor network techniques.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In the thermofield approach, the first step is to introduce the auxiliary environment E^textaux of non-interacting bosonic modes of negative frequencies:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hat H^textaux = hat H - sum_k omega_k hat c_k^dagger hat c_k","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where the Hamiltonian hat H is the bosonic Hamiltonian defined in Eq. \\ref{eq:bosonic_ham}. The two environments, of positive and negative frequencies, are assumed to be in a thermal environment at inverse temperature beta; the second step is to apply a thermal Bogoliubov transformation to change the basis. The applied transformation produces two-modes squeezed states:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"         hat a_1k=e^-iG  hat b_k e^iG= cosh(theta_k) hat b_k -sinh(theta_k)  hat c_k^dagger \n         hat a_2k=e^-iG hat c_k e^iG= cosh(theta_k)  hat c_k -sinh(theta_k)  hat b_k^dagger","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where the exponent of the squeeze operator is G = i sum_k theta_k(hat b_k^dagger hat c_k^dagger-hat c_k hat b_k), and theta_k is dependent on the temperature as in the following relations, where the number of excitations in the k-th mode is n_k = 1(e^beta omega_k-1):","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"         cosh(theta_k) = sqrt1+n_k = sqrtfrac11-e^-beta omega_k \n         sinh(theta_k) =quadsqrtn_kquad= sqrtfrac1e^beta omega_k-1","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The Bogoliubov transformation defines a new squeezed vacuum state, which we write in terms of the vacuum state ketOmega_0 of the operators hat b_k, hat c_k:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    Omegarangle = e^iG Omega_0rangle quad textsuch that quad hat a_1k Omegarangle = 0  hat a_2k Omegarangle = 0","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"From the vacuum state, we can obtain the thermal state of the original environment:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hat rho_E = textTr_textaux OmegaranglelangleOmega ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"and it can be now used as pure an initial state for both of the environments. Moreover, the expectation value on ketOmega of the number of physical modes hat n_k does not vanish:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    n_k= langleOmega hat b_k^dagger hat b_k Omegarangle = sinh^2(theta_k)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Therefore, solving the dynamics given by the original Hamiltonian hat H, starting from the initial condition hat rho_S(0) otimes hat rho_E(beta), is equivalent to solving the dynamics given by the following Hamiltonian:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"       hat H = hat H_S +hat H_E +hat H_I  = \n       = overbracehat A_S^hat H_S + overbracesum_k omega_k big(hat a_1k^dagger hat a_1k - hat a_2k^dagger hat a_2k big)^H_E + overbracehat L_S otimes sum_k g_1k(hat a_1k^dagger + hat a_1k)+hat L_S otimes sum_k g_2k(hat a_2k^dagger + hat a_2k)^H_I","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where hat L_S = hat L_S^dagger, considering hat rho_S(0) otimes ketOmegabraOmega as the initial state of system and environment. It is this Hamiltonian that is mapped on two chains with TEDOPA, to be able to perform the time evolution using tensor network techniques. ","category":"page"},{"location":"theory/#Computation-of-the-chain-coefficients","page":"Theoretical Background","title":"Computation of the chain coefficients","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A useful property of the orthonormal polynomials is that they obey a recurrence relation","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    P_n(omega) = (C_n-1omega - A_n-1)P_n-1(omega) + B_n-1P_n-2(omega) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where A_n is related to the first moment of P_n, B_n and C_n to the norms of P_n and P_n-1[appel_mathematics_2007]. This recurrence relation can be used to construct the polynomials with the conditions that P_0(omega) = p_0^-1 = left(int_mathbbR^+ J(omega)mathrmdomega right)^-frac12 and P_-1(omega) = 0, with bullet the norm of bullet with respect to the measure J(omega), and P_n(omega) = p_n(omega)p_n^-1 ; where the polynomials p_n_ninmathbbN are the so called monic polynomials where the factor a_n in front of omega^n is equal to 1.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The energy of the chain mode n is given by varepsilon_n = A_n C_n^-1 and t_n=C_n^-1 is the coupling between mode n and n+1[chin_exact_2010].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The system couples only to the first mode with the coupling strength kappa = p_0.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Explain that for some weight function/SD they are known analytically and that for others we can use the build-in routines inspired by Gautschi or the PolyChaos.jl package.","category":"page"},{"location":"theory/#Tensor-Networks","page":"Theoretical Background","title":"Tensor Networks","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A multipartite quantum state psirangle, e.g. a N-site system where the sites can each be in a state phi_irangle belonging to a d-dimensional Hilbert space, can be written as follows","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    psirangle = sum_i_kc_i_1ldots i_Nphi_i_1rangleotimesldotsotimesphi_i_Nrangle ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where the complex numbers c_i_1ldots i_N are the amplitudes of each state phi_i_1rangleotimesldotsotimesphi_i_Nrangle whose superpositions form in full generality the state psirangle. Thus the state psirangle can be completely represented by a rank-N tensor c that is the collection of all possible amplitudes c_i_1ldots i_N. Here by the rank of a tensor, we simply mean the number of indices it has.","category":"page"},{"location":"theory/#MPS","page":"Theoretical Background","title":"MPS","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The tensor c of a quantum state psirangle corresponding to a one-dimensional system can be decomposed into a product of N smaller rank-3 tensors T_k (except for the first and last sites where the tensors will have a rank-2)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    c_i_1ldots i_N = sum_alpha T^alpha_1_i_1T^alpha_1alpha_2 _i_2T^alpha_2alpha_3 _i_3ldots T^alpha_N-1_i_N  ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In this form, the local tensor T_k contains the information on the quantum state on site k and its relation (especially the entanglement) with the neighbouring sites.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The decomposition of the tensor of the amplitudes of a quantum state into a product of smaller rank tensors is called a Matrix Product State decomposition.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The contracted indices alpha_k between the tensors are called virtual indices and carry information about the correlations between bi-partitions of the state at bond k. The number of different values a virtual index can take is called the bond dimension and is denoted D. The free indices i_k associated with local quantum states are called physical indices. Thus, they can take d values (with d the dimension of the local Hilbert space).","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Any state in the Hilbert space of a one-dimensional many-body system can in principle be represented by a MPS by choosing a sufficiently large value for the bond dimension D [Orus]. On top of this intellectually satisfying property of MPSs being a dense set of states for a 1d-system, they can also be used as a practical Ansätze for a many-body quantum states by setting a maximal allowed value chi for the bond dimension D. In doing so, we restrict ourselves to a corner of the total Hilbert space. The rationale behind this Ansatz is the following: if the initial quantum state of a many-body system has a low bond dimension (typically if the initial state is a product state with D = 1), then in a finite time it will only be able to explore a region of the Hilbert space that is not to far away from its starting point. Thus, the bond dimension will not have the time to diverge exponentially [poulin_quantum_2011]. However, depending on the physical system at hand, this sub-manifold of the Hilbert space could still be \"too large\". There is an additional reason that explains why MPSs are good Ansätze for 1d physical systems. Most many-body Hamiltonians we (physicists) are interested in are local, meaning that the interactions they describe involve objects that are \"neighbours\". For such Hamiltonians, the ground states (outside of potential critical phases) follow the so called area law for the entanglement entropy [srednicki_entropy_1993][vidal_entanglement_2003][wolf_area_2008]. This law states that the entanglement entropy S_vN of a bi-partition of the system is proportional, not to the volume of the partition as one might expect, but to the hyper-surface of the partition's boundary; hence the name \"area law\". For a 3d system this corresponds to an actual surface area A, S_vN sim A; for a 2d system it corresponds to the length L of the partition's boundary, S_vN sim L; and in 1d the boundary reduces to a point, thus the entropy will be independent of the size of the system S_vN sim textconstant. The MPSs are states that satisfy this area law.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"An application of the Singular Value Decomposition is to create efficient approximations of quantum states to perform computations. The main idea is to reduce the content of the MPS to keep only the parts that contain the physics of interest. One method to realise this approximation is to do a SVD on each of the tensors of the MPS after each time step of the state time-evolution and to trim the smallest singular values in order to decrease the bond dimension of the MPS down to a chosen maximal value chi. The corresponding columns and rows of the unitary matrices U and V^dagger are also removed. Then, the trimmed matrices tildeU, tildeS and tildeV^dagger are contracted back to give an approximated tensor T with a smaller bond dimension. Another way to apply the restricted rank approximation is to restrict oneself into working in a manifold of fixed bond dimension D and to use methods that can enforce this constraint.","category":"page"},{"location":"theory/#MPO","page":"Theoretical Background","title":"MPO","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In order to compute expectation values of observables or apply unitary transformations to a quantum state, we need a TN representation of operators. In the same fashion as a one-dimensional quantum state can be represented as a MPS, operators acting on those states can be represented as Matrix Product Operators (MPO). For an operator hatO, its MPO can be defined as follows","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatO = sum_i_ki_k^ w W^i_1 i^_1_1 w_0w_1ldots  W^i_N i^_N_N w_N-1w_N phi_i_1^ldots phi_i_N^ranglelanglephi_i_1ldots phi_i_N ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The contracted indices between the tensors are called virtual indices. The free indices are called physical indices and correspond to the different input and output local quantum states.  They can take d values (with d the dimension of the local Hilbert space).","category":"page"},{"location":"theory/#TTN","page":"Theoretical Background","title":"TTN","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A natural extension to the MPS is the (loop-free) tree tensor network.  A TTN is a generalisation of the MPS wherein each site, instead of being connected to only one other site to its right, may be connected to any arbitrary number of child sites. Provided the tree does not contain any loops, everything that one can do to an MPS/MPO can be extended straight-forwardly to TTN states and TTN operators.  The generalisation to trees introduces no new conceptual complexity (only implementational complexity). The sites of a TTN are usually referred to as nodes.  For our purposes, every node of a TTN state and operator has one parent leg, and any number (including zero) of child legs.  The first node is known as the head-node and has a dummy parent leg with dimension 1.","category":"page"},{"location":"theory/#Time-Dependent-Variational-Principle","page":"Theoretical Background","title":"Time-Dependent Variational Principle","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The original idea behind TDVP goes back to Dirac [dirac_note_1930] and Frenkel [frenkel_wave_1934]. The main point, in the modern tensor networks formulation, is that instead of solving the Schrödinger equation and then truncating the MPS representation of the quantum state, one can solve the equations of motion projected into a space of restricted bond dimension [haegeman_timedependent_2011][haegeman_unifying_2016].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The general formulation of the Dirac-Frenkel Variational Principle [raab_diracfrenkelmclachlan_2000] is that one looks for a solution varphirangle in mathcalM of the Schrödinger equation where mathcalM subset mathcalH is a manifold of the total Hilbert space mathcalH in which we think that the relevant physical states `live'.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"We define T_varphiranglemathcalM the tangent space of mathcalM around the state varphirangle. The criterion to find varphirangle is that for every state chirangle in T_varphiranglemathcalM","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    langlechileft(fracmathrmdmathrmdt - frac1mathrmihbarhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"which can be interpreted as saying that the time evolution procedure should keep varphirangle inside of the manifold mathcalM.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The term variational in the name of the method comes from the fact that in practice one aims at minimising the right-hand side of the hereinabove Eq. to find varphirangle.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Introducing hatP_T_varphiranglemathcalM the projector onto the tangent space T_varphiranglemathcalM, we can write the state chirangle = hatP_T_varphiranglemathcalMphirangle with phirangle a state in mathcalH. Leading to","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    forall phirangle in mathcalH  langlephihatP_T_varphiranglemathcalMleft(fracmathrmdmathrmdt - frac1mathrmihbarhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Because the time derivation and the projector commute, we have","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    forall phirangle in mathcalH  langlephileft(fracmathrmdmathrmdt - frac1mathrmihbarhatP_T_varphiranglemathcalMhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This equation must be true for any phirangle in mathcalH, Eq.~(\\ref{eq:DiracFrenkel1}) can thus be written","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    left(fracmathrmdmathrmdt - frac1mathrmihbarhatP_T_varphiranglemathcalMhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In the context of MPS, the manifold mathcalM will correspond to the space of full-ranked MPS of a given bond dimension D, and the tangent space will be the space spanned by variations of single MPS tensors. The projector defines an effective Hamiltonian under which the dynamics are constrained on mathcalM. Constraining the dynamics on a manifold, introduces a projection error: the time evolution will obey to an effective Hamiltonian different from the starting one. After the introduction of TDVP as a time evolution method for MPS, Haegeman et al. pointed out [haegeman_unifying_2016] that there exist an analytical decomposition for the projector operator hatmathcalP that simplifies the resolution of the equation, turning the problem into one where each matrix A_i can be updated with an effective on site Hamiltonian hat H_texteff via a Schroedinger like equation. The effective Hamiltonian hat H_texteff is a contraction of the Hamiltonian MPO and the current state of the other matrices composing the MPS. This allows to do a sequential update.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"There exist different versions of the TDVP algorithm. In MPSDynamics.jl three methods have been so far implemented:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"the one-site TDVP (1TDVP)\nthe two-sites TDVP (2TDVP) \nthe adaptive TDVP (DTDVP) [dunnett_efficient_2021]","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The main advantage of the one-site 1TDVP algorithm is that it preserves the unitarity of the MPS during the time evolution. Its main problem, conversely, is that the time evolution is constrained to happen on a manifold constituted by tensors of fixed bond dimension, a quantity closely related to the amount of entanglement in the MPS, and such a bond dimension has therefore to be fixed before the beginning of the time evolution. This strategy will necessarily be non optimal: the growth of the bond dimensions required to describe the quantum state should ideally mirror the entanglement growth induced by the time evolution. 2TDVP allows for such a dynamical growth of the bond dimensions, and therefore better describes the entanglement in the MPS. It suffers however of other drawbacks: first of all, a truncation error is introduced (by the means of an SVD decomposition), which entails a loss of unitarity of the time-evolved MPS. Moreover, 2TDVP has bad scaling properties with the size of the local dimensions of the MPS: this is a major issue when dealing with bosons. The DTDVP algorithm combines the best features of 1TDVP and 2TDVP: it preserves unitarity, it has the same scaling properties of 1TDVP, and it adapts the bond dimensions to the entanglement evolution at each site and at each time-step. DTDVP does not suffer from a truncation error, but introduces only a projection error.","category":"page"},{"location":"theory/#Bibliography","page":"Theoretical Background","title":"Bibliography","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[chin_exact_2010]: Chin, A. W.; Rivas, Á.; Huelga, S. F.; Plenio, M. B. Exact Mapping between System-Reservoir Quantum Models and Semi-Infinite Discrete Chains Using Orthogonal Polynomials. Journal of Mathematical Physics 2010, 51 (9), 092109. https://doi.org/10.1063/1.3490188.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[chin_role_2013]: Chin, A. W.; Prior, J.; Rosenbach, R.; Caycedo-Soler, F.; Huelga, S. F.; Plenio, M. B. The Role of Non-Equilibrium Vibrational Structures in Electronic Coherence and Recoherence in Pigment–Protein Complexes. Nature Phys 2013, 9 (2), 113–118. https://doi.org/10.1038/nphys2515.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[alvertis_nonequilibrium_2019]: Alvertis, A. M.; Schröder, F. A. Y. N.; Chin, A. W. Non-Equilibrium Relaxation of Hot States in Organic Semiconductors: Impact of Mode-Selective Excitation on Charge Transfer. J. Chem. Phys. 2019, 151 (8), 084104. https://doi.org/10.1063/1.5115239.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dunnett_influence_2021]: Dunnett, A. J.; Gowland, D.; Isborn, C. M.; Chin, A. W.; Zuehlsdorff, T. J. Influence of Non-Adiabatic Effects on Linear Absorption Spectra in the Condensed Phase: Methylene Blue. J. Chem. Phys. 2021, 155 (14), 144112. https://doi.org/10.1063/5.0062950.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[caycedosoler_exact_2022]: Caycedo-Soler, F.; Mattioni, A.; Lim, J.; Renger, T.; Huelga, S. F.; Plenio, M. B. Exact Simulation of Pigment-Protein Complexes Unveils Vibronic Renormalization of Electronic Parameters in Ultrafast Spectroscopy. Nat Commun 2022, 13 (1), 2912. https://doi.org/10.1038/s41467-022-30565-4.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[orus_practical_2014]: Orus, R. A Practical Introduction to Tensor Networks: Matrix Product States and Projected Entangled Pair States. Annals of Physics 2014, 349, 117–158. https://doi.org/10.1016/j.aop.2014.06.013.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[paeckel_timeevolution_2019]: Paeckel, S.; Köhler, T.; Swoboda, A.; Manmana, S. R.; Schollwöck, U.; Hubig, C. Time-Evolution Methods for Matrix-Product States. Annals of Physics 2019, 411, 167998. https://doi.org/10.1016/j.aop.2019.167998.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[prior_efficient_2010]: Prior, J.; Chin, A. W.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Strong System-Environment Interactions. Phys. Rev. Lett. 2010, 105 (5), 050404. https://doi.org/10.1103/PhysRevLett.105.050404.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[woods_simulating_2015]: Woods, M. P.; Cramer, M.; Plenio, M. B. Simulating Bosonic Baths with Error Bars. Phys. Rev. Lett. 2015, 115 (13), 130401. https://doi.org/10.1103/PhysRevLett.115.130401.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[tamascelli_efficient_2019]: Tamascelli, D.; Smirne, A.; Lim, J.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Finite-Temperature Open Quantum Systems. Phys. Rev. Lett. 2019, 123 (9), 090402. https://doi.org/10.1103/PhysRevLett.123.090402.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dunnett_simulating_2021]: Dunnett, A. J.; Chin, A. W. Simulating Quantum Vibronic Dynamics at Finite Temperatures With Many Body Wave Functions at 0 K. Front. Chem. 2021, 8. https://doi.org/10.3389/fchem.2020.600731.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[lacroix_unveiling_2021]: Lacroix, T.; Dunnett, A.; Gribben, D.; Lovett, B. W.; Chin, A. Unveiling Non-Markovian Spacetime Signaling in Open Quantum Systems with Long-Range Tensor Network Dynamics. Phys. Rev. A 2021, 104 (5), 052204. https://doi.org/10.1103/PhysRevA.104.052204.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[appel_mathematics_2007]: Appel, W. Mathematics for Physics and Physicists; Princeton University Press, 2007.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[devega_thermo_2015]: de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[Orus]: Orus, R. A Practical Introduction to Tensor Networks: Matrix Product States and Projected Entangled Pair States. Annals of Physics 2014, 349, 117–158. https://doi.org/10.1016/j.aop.2014.06.013.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[poulin_quantum_2011]: Poulin, D.; Qarry, A.; Somma, R.; Verstraete, F. Quantum Simulation of Time-Dependent Hamiltonians and the Convenient Illusion of Hilbert Space. Phys. Rev. Lett. 2011, 106 (17), 170501. https://doi.org/10.1103/PhysRevLett.106.170501.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[srednicki_entropy_1993]: Srednicki, M. Entropy and Area. Phys. Rev. Lett. 1993, 71 (5), 666–669. https://doi.org/10.1103/PhysRevLett.71.666.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[vidal_entanglement_2003]: Vidal, G.; Latorre, J. I.; Rico, E.; Kitaev, A. Entanglement in Quantum Critical Phenomena. Phys. Rev. Lett. 2003, 90 (22), 227902. https://doi.org/10.1103/PhysRevLett.90.227902.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[wolf_area_2008]: Wolf, M. M.; Verstraete, F.; Hastings, M. B.; Cirac, J. I. Area Laws in Quantum Systems: Mutual Information and Correlations. Phys. Rev. Lett. 2008, 100 (7), 070502. https://doi.org/10.1103/PhysRevLett.100.070502.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dirac_note_1930]: Dirac, P. A. M. Note on Exchange Phenomena in the Thomas Atom. Mathematical Proceedings of the Cambridge Philosophical Society 1930, 26 (3), 376–385. https://doi.org/10.1017/S0305004100016108.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[frenkel_wave_1934]: Frenkel, Y. Wave Mechanics, Advanced General Theory; Oxford, 1934; Vol. 1.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[haegeman_timedependent_2011]: Haegeman, J.; Cirac, J. I.; Osborne, T. J.; Pižorn, I.; Verschelde, H.; Verstraete, F. Time-Dependent Variational Principle for Quantum Lattices. Phys. Rev. Lett. 2011, 107 (7), 070601. https://doi.org/10.1103/PhysRevLett.107.070601.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[haegeman_unifying_2016]: Haegeman, J.; Lubich, C.; Oseledets, I.; Vandereycken, B.; Verstraete, F. Unifying Time Evolution and Optimization with Matrix Product States. Phys. Rev. B 2016, 94 (16), 165116. https://doi.org/10.1103/PhysRevB.94.165116.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[raab_diracfrenkelmclachlan_2000]: Raab, A. On the Dirac–Frenkel/McLachlan Variational Principle. Chemical Physics Letters 2000, 319 (5), 674–678. https://doi.org/10.1016/S0009-2614(00)00200-1.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dunnett_efficient_2021]: Dunnett, A. J.; Chin A. W. Efficient bond-adaptive approach for finite-temperature open quantum dynamics using the one-site time-dependent variational principle for matrix product states. Physical Review B, 104(21):214302, Dec 2021. doi:10.1103/PhysRevB.104.214302. ","category":"page"},{"location":"examples/bath-observables/#Inspecting-the-bath-by-undoing-the-chain-mapping","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"","category":"section"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"Here we give some context on the example script provided in MPSDynamics/example/bath-observables.jl. This example demonstrates the setup and execution of a simulation for a two-level system coupled to an Ohmic bath at finite temperature, where we exploit the access to the chain observables to:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"undo the chain mapping[chin_exact_2010], thus obtaining their representation in the extended bath of T-TEDOPA [tamascelli_efficient_2019], characterized by J(omega beta)\ninverting the thermofield transformation[devega_thermo_2015], thus obtaining the representation of the physical frequencies in the original environment, characterized by J(omega)","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"T-TEDOPA allows to substitute a thermally occupied bath by an extended one, in the pure state of the vacuum, extending the bath of frequencies to negative values: the creation from the system of a mode of negative frequency in the extended bath of frequencies corresponds to the absorption of energy for the system from the thermally occupied modes of the environment. However, by exploiting the thermofield transformation, it is possible to recover the picture of the occupations of the steady states in the physical bath of frequencies[riva_thermal_2023]. ","category":"page"},{"location":"examples/bath-observables/#The-code","page":"Inspecting the bath by undoing the chain mapping","title":"The code","text":"","category":"section"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"We start by defining the parameters of the simulation:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"d = 10      # number of Fock states of the chain modes\nN = 60      # length of the chain\nα = 0.01    # coupling strength\nω0 = 0.2  # TLS gap\ns = 1       # ohmicity\nωc = 1.  # Cut-off of the spectral density J(ω)\nβ = 20    # Thermalized environment","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"We set the specifics of the simulation:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"method = :TDVP1         # time-evolution method\nconv = 3                # bond dimension for the TDVP1\ndt = 0.5                # time step\ntfinal = 60.0           # simulation time","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"And then compute the chain coefficients, i.e. on-site energies epsilon_i, hopping energies t_i, and system-chain coupling c_0, that define the chain representation of the pure-dephasing model:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"cpars = chaincoeffs_finiteT(N, β; α=α, s=s, J=nothing, ωc=ωc, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=false)","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"with this, we can compute the corresponding MPO, and the initial state in MPS form (1sqrt2(0rangle + 1rangle)):","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"H = puredephasingmpo(ω0, d, N, cpars)\n\nψ = zeros(2)\nψ[1] = 1/sqrt(2)\nψ[2] = 1/sqrt(2)\n\nA = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...])","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"We can now define the observables we are interested in computing. Importantly, we not only compute observables related to the system, but also to the chain modes, so that we can inspect the environment.","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"ob1 = OneSiteObservable(\"sz\", sz, 1)\nob2 = OneSiteObservable(\"sx\", sx, 1)\nob3 = OneSiteObservable(\"chain_mode_occupation\", numb(d), (2,N+1))\nob4 = OneSiteObservable(\"c\", crea(d), collect(2:N+1))\nob5 = OneSiteObservable(\"cdag\", crea(d), collect(2:N+1))\nob6 = TwoSiteObservable(\"cdagc\", crea(d), anih(d), collect(2:N+1), collect(2:N+1))\nob7 = TwoSiteObservable(\"cdagcdag\", crea(d), crea(d), collect(2:N+1), collect(2:N+1))\nob8 = TwoSiteObservable(\"cc\", anih(d), anih(d), collect(2:N+1), collect(2:N+1))","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"with this we run the simulation:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"A, dat = runsim(dt, tfinal, A, H, prec=1E-4;\n                name = \"Bath observables in the pure dephasing model\",\n                method = method,\n                obs = [ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8],\n                convobs = [ob1],\n                params = @LogParams(ω0, N, d, α, s, ψ),\n                convparams = conv,\n                reduceddensity = true,\n                verbose = false,\n                save = false,\n                plot = true,\n                );","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"After the simulation, we need to post-process the data a bit, in order to map the correlations from the chain representation to the original environment. We start by defining the matrices associated to the mean values of c and c^dagger:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"T = length(dat[\"data/times\"])\n\nconstr = Array{ComplexF64}(undef, N, N, T)\ndestr = Array{ComplexF64}(undef, N, N, T)\nfor t in 1:T\n    constr[:,:,t] = diagm(0 => dat[\"data/cdag\"][:,t])\n    destr[:,:,t] = diagm(0 => dat[\"data/c\"][:,t])\nend","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"During a numerical simulation we work with chain of finite length N. This truncation on chain modes, introduces a sampling on the modes in the original star-like environment. To recover the frequency modes that are implicitly sampled, one has to diagonalize the tri-diagonal Ntimes N matrix H^textchain, where the diagonal is formed by the e_n coefficients, that is the chain's frequencies, and the upper and lower diagonals by the N-1 hopping coefficients t_n. The unitary matrix that defines the change of basis from the star-like to the chain-like environment is U_n, constituted by the eigenvectors of H^textchain. In the code, we use the eigenchain function:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"omeg = eigenchain(cpars, nummodes=N).values","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"At each time step of the simulation, a number of one-site and two-sites observables where evaluated on the chain. To obtain their value in the extended bath of T-tedopa, characterized by J(omegabeta), the unitary transformation that maps the extended bath Hamiltonian into the chain representation has to be reversed. For instance, when measuring the single site hat n^c_i=hat c_i^dagger hat c_i occupation number, we are not measuring the occupation number of the bosonic mode associated to the omega_i frequency, but the occupation number of the i-th chain mode. Therefore to calculate the number of modes of the environment associated to a specific frequency omega_i, the mapping must be reversed, to obtain the diagonal representation of the bosonic number operator:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"beginaligned\nhat n^b_i = hat b_i^dagger hat b_i = sum_kl U_ik^* hat c_k^dagger hat c_l U_li  \nendaligned","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"This is done in the code using the measuremodes(X, cpars[1], cpars[2]) function, which outputs the vector of the diagonal elements of the operators, in the following way:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"bath_occup = mapslices(X -> measuremodes(X, cpars[1], cpars[2]), dat[\"data/cdagc\"], dims = [1,2])\ncdag_average = mapslices(X -> measuremodes(X, cpars[1], cpars[2]), constr, dims = [1,2])\nc_average = mapslices(X -> measuremodes(X, cpars[1], cpars[2]), destr, dims = [1,2])","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"To compute the correlators, we need the full matrix in the original basis. We therefore use the measurecorrs function:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"cc_average = mapslices(X -> measurecorrs(X, cpars[1], cpars[2]), dat[\"data/cc\"], dims = [1,2])\ncdagcdag_average = mapslices(X -> measurecorrs(X, cpars[1], cpars[2]), dat[\"data/cdagcdag\"], dims = [1,2])\n\ncorrelations_c = [\n    cc_average[i, j, t] - c_average[i, 1, t] .* c_average[j, 1, t]\n    for i in 1:size(cc_average, 1), j in 1:size(cc_average, 2), t in 1:size(cc_average, 3)\n]\ncorrelations_cdag = [\n    cdagcdag_average[i, j, t] - cdag_average[i, 1, t] .* cdag_average[j, 1, t]\n    for i in 1:size(cdagcdag_average, 1), j in 1:size(cdagcdag_average, 2), t in 1:size(cdagcdag_average,3)\n]","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"It is possible to invert the thermofield transformation (details in [riva_thermal_2023]). The expression of the mean value of the number operator for the physical modes can be expressed as a function of mean values in the extended bath, which we denote langle hat a_2k^dagger hat a_2k rangle:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"beginaligned\n    langle hat b_k^dagger hat b_k rangle = coshtheta_ksinhtheta_k (langle hat a_2khat a_1krangle + langle hat a_1k^daggerhat a_2k^daggerrangle ) + sinh^2theta_k (1+ langle hat a_2k^dagger hat a_2k rangle ) ++ cosh^2theta_k langle hat a_1k^dagger hat a_1k rangle\nendaligned","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"We remark that in the thermofield case, a negative frequency omega_2k is associated to each positive frequency omega_1k. The sampling is therefore symmetric around zero. This marks a difference with T-TEDOPA, where the sampling of frequencies was obtained through the thermalized measure dmu(beta) = sqrtJ(omega beta)domega, and was not symmetric. To recover the results for the physical bath of frequencies starting from the results of our simulations, that were conducted using the T-TEDOPA chain mapping, we need to do an extrapolation for all of the mean values, in order to have their values for each omega at -omega as well. This is done in the code with the physical_occup function:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"bath_occup_phys = physical_occup(cdagcdag_average[:,:,T], cc_average[:,:,T], omeg, bath_occup[:,:,T], β, N)","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"Finally, in the pure dephasing case, it is also possible to obtain the analytical prediction of the time evolution of the occupations of the bath's modes, so that we can compare our numerical results with the analytical ones, exploiting the Heisenberg time evolution relation:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"beginaligned\nfracd langle hat b_omega rangledt = -i langle hat b_omega hat H rangle = - i omega langlehat b_omega rangle - i fraclangle hat sigma_x rangle2 sqrtJ(omega beta)     \nfracd langle hat n_omega rangledt = -i langlehat b_omega^dagger hat b_omega hat H rangle= 2 fracJ(omegabeta)omega sin(omega t)\nendaligned","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"To this end, it is convenient to choose one of the eigenstates of hat sigma_z as the initial state, so that langle hat sigma_x rangle = pm 1. By solving these differential equations, one obtains the time evolved theoretical behavior of the bath. We define the function for the comparison with analytical predictions:","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"Johmic(ω,s) = (2*α*ω^s)/(ωc^(s-1))\n\ntime_analytical = LinRange(0.0, tfinal, Int(tfinal))\n\nΓohmic(t) = - quadgk(x -> Johmic(x,s)*(1 - cos(x*t))*coth(β*x/2)/x^2, 0, ωc)[1]\n\nDecoherence_ohmic(t) = 0.5 * exp(Γohmic(t))\n\n\nα_theo = 0.25 * α\nfunction Jtherm(x)\n    if 1 >= x >= 0\n        return +α_theo * abs(x)^s * (1 + coth(β*0.5*x))\n    elseif -1 <= x <= 0\n        return -α_theo * abs(x)^s * (1 + coth(β*0.5*x))\n    else\n        return 0\n    end\nend\n\nbath_occup_analytical(ω, t) = abs(Jtherm(ω))/(ω^2)*2*(1-cos(ω*t)) ","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"We conclude the example by plotting.","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"ρ12 = abs.(dat[\"data/Reduced ρ\"][1,2,:])\n\np1 = plot(time_analytical, t->Decoherence_ohmic(t), label=\"Analytics\", title=L\"Pure Dephasing, Ohmic $s=%$s$, $\\beta = %$β ~\\mathrm{K}$\", linecolor=:black, xlabel=\"Time (arb. units)\", ylabel=L\"Coherence $|\\rho_{12}(t)|$\", linewidth=4, titlefontsize=16, legend=:best, legendfontsize=16, xguidefontsize=16, yguidefontsize=16, tickfontsize=10)\np1 = plot!(dat[\"data/times\"], ρ12, lw=4, ls=:dash, label=\"Numerics\")\n\ncumul = [bath_occup_analytical(omeg[i], tfinal)*(omeg[i+1]-omeg[i]) for i in 1:(length(omeg)-1)]\n\np2 = plot(omeg[1:length(omeg)-1], cumul, lw = 4, linecolor=:black,\n             xlabel=L\"\\omega\", ylabel=L\"\\langle n^b_\\omega \\rangle\", label=\"Analytics\",\n             title=\"Mode occupation in the extended bath\")\np2 = plot!(omeg, bath_occup[:, :, T], lw=4, ls=:dash, label=\"Numerics\")\n\np3 = heatmap(omeg, omeg, abs.(real.(correlations_cdag[:,:,T]) .+ im*imag.(correlations_cdag[:,:,T])), \n            xlabel=L\"\\omega\",\n            ylabel=L\"\\omega\", title=\"Environmental correlations\")\n\n\nMhalf = Int(length(omeg)*0.5)+1\nM = length(omeg)\n\np4 = plot(omeg[Mhalf:M], bath_occup_phys, lw=4,\n            xlabel=L\"\\omega\", ylabel=L\"\\langle n^b_\\omega \\rangle\",\n            title=\"Mode occupation in the physical bath\")\n\nplot(p1, p2, p3, p4, layout = (2, 2), size = (1400, 1200))","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"___________________","category":"page"},{"location":"examples/bath-observables/#References","page":"Inspecting the bath by undoing the chain mapping","title":"References","text":"","category":"section"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"[chin_exact_2010]: Chin, A. W.; Rivas, Á.; Huelga, S. F.; Plenio, M. B. Exact Mapping between System-Reservoir Quantum Models and Semi-Infinite Discrete Chains Using Orthogonal Polynomials. Journal of Mathematical Physics 2010, 51 (9), 092109. https://doi.org/10.1063/1.3490188.","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"[tamascelli_efficient_2019]: Tamascelli, D.; Smirne, A.; Lim, J.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Finite-Temperature Open Quantum Systems. Phys. Rev. Lett. 2019, 123 (9), 090402. https://doi.org/10.1103/PhysRevLett.123.090402.","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"[devega_thermo_2015]: de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.","category":"page"},{"location":"examples/bath-observables/","page":"Inspecting the bath by undoing the chain mapping","title":"Inspecting the bath by undoing the chain mapping","text":"[riva_thermal_2023]: Riva, A.; Tamascelli, D.; Dunnett, A. J.; Chin, A. W. Thermal cycle and polaron formation in structured bosonic environments. Phys. Rev. B 2023, 108, 195138, https://doi.org/10.1103/PhysRevB.108.195138.","category":"page"},{"location":"examples/puredephasing/#Pure-Dephasing","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"","category":"section"},{"location":"examples/puredephasing/#Context","page":"Pure-Dephasing","title":"Context","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The Pure-Dephasing Model describes a two-level system interacting linearly with an environment characterised by a spectral density (SD) J(omega). The coupling only acts on diagonal terms through the sigma_z operator. The Hamiltonian reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"        hatH = fracomega_02hatsigma_z + int_0^+inftyomega hata^dagger_omegahata_omega mathrmdomega + frachatsigma_z2int_0^+inftysqrtJ(omega)(hata_omega + hata^dagger_omega)mathrmdomega","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Although this interaction will not change the population of the two-level system, the coherences between the two states will vary due to the environment. Introducing the two-level system reduced density matrix rho_ij(t) with ij in (01), the diagonal terms rho_ii(t) are the populations of the states and the anti-diagonal terms rho_ij(t) with i neq j are the coherences between the two states. The effect of the sigma_z bath interaction is to decouple the two states 0rangle and 1rangle. ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The density matrix can be calculated within the MPS formalism with the MPO psirangle langle psi. Tracing out the environment leads to the reduced density matrix. This can be done with the function MPSDynamics.rhoreduced_1site. ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"An analytical formula can be found for the decoherence function Gamma(t), taking into account the SD as well as the temperature of the environment [breuer]","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    Gamma(t) = - int_0^omega_c mathrmd omega J(omega)frac(1 - cos(omega t))omega^2 coth(βomega2) ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"with beta = (k_B T)^-1. For the case where beta longrightarrow infty, the integral reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    Gamma(t) = - int_0^omega_c mathrmd omega J(omega)frac(1 - cos(omega t))omega^2 ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The time-dependent anti-diagonal terms of the reduced density matrix are then expressed as","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    rho_12(t) = rho_21(t)^* =rho_12(0) exp(Gamma(t)) ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Setting up the initial two-level system as a cat state psirangle_S(0) = frac0rangle pm 1ranglesqrt2, this leads to rho_12(0)=frac12.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Here we break out and comment the script in MPSDynamics/examples/puredephasing.jl and MPSDynamics/examples/puredephasing_temperature.jl to show how to simulate this model with an Ohmic SD (hard cut-off) using the T-TEDOPA method as implemented in MPSDynamics.jl.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The T-TEDOPA method relies on a truncated chain mapping that transform the initial Hamiltonian into","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"        hatH = fracomega_02 hatsigma_z +  c_0 frachatsigma_z2(hatb_0^dagger + hatb_0) + sum_i=0^N-1 t_i (hatb_i+1^dagger hatb_i + mathrmhc) + sum_i=0^N-1 epsilon_i hatb_i^dagger hatb_i","category":"page"},{"location":"examples/puredephasing/#The-code","page":"Pure-Dephasing","title":"The code","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"First, we load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, the LaTeXStrings.jl one to be able to use LaTeX in the plots and eventually QuadGK.jl to perform the analytical integral calculations. A notation is introduced for +∞.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"using MPSDynamics, Plots, LaTeXStrings, QuadGK\n\nconst ∞  = Inf","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We then define variables for the physical parameters of the simulation. Among these, two are convergence parameters:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes\nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The value of β determines whether the environment is thermalized or not. The example as it is is the zero-temperature case. For the finite-temperature case, 'β = ∞' has be commented instead of the line above that precises a β value.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 10 # number of Fock states of the chain modes\n\nN = 30 # length of the chain\n\nα = 0.01 # coupling strength\n\nω0 = 0.008 # TLS gap\n\ns = 1 # ohmicity\n\nωc = 0.035 # Cut-off of the spectral density J(ω)\n\n#β = 100 # Thermalized environment\n\nβ = ∞ # Case zero temperature T=0, β → ∞","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The chain coefficient have then to be calculated. This part differs for the zero-temperature case and the thermalized bath. For β = , the chain coeffficients can be calculated with the function MPSDynamics.chaincoeffs_ohmic whereas the function MPSDynamics.chaincoeffs_finiteT is used when T neq 0  textK:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"if β == ∞\n    cpars = chaincoeffs_ohmic(N, α, s; ωc=ωc)  # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0\nelse\n    cpars = chaincoeffs_finiteT(N, β; α=α, s=s, J=nothing, ωc=ωc, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=false)  # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0\n    #= #If cpars is stored in \"../ChainOhmT/ohmicT\" \n    curdir = @__DIR__\n    dir_chaincoeff = abspath(joinpath(curdir, \"../ChainOhmT/ohmicT\"))\n    cpars  = readchaincoeffs(\"$dir_chaincoeff/chaincoeffs.h5\",N,α,s,β) # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0\n    =#\nend","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"An option is provided if the coefficient are saved to be reused.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present two one-site implementation of TDVP that both preserves the unitarity of the evolution:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D\nthe adaptive method with the keyword :DTDVP where the bond dimension is locally increased at each time step if the TDVP projection error crosses a threshold value","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Logically the constant bond dimension of the MPS for TDVP1 and the threshold of the projection error for DTDVP are their respective convergence parameter.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 1.0 # time step\n\ntfinal = 300.0 # simulation time\n\nmethod = :TDVP1 # time-evolution method\n\n#method = :DTDVP # time-evolution method\n\nD = 2 # MPS bond dimension","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Using MPSDynamics.jl built-in methods we define the Pure Dephasing model MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\nH = puredephasingmpo(ΔE, d, N, cpars)\n\n# Initial electronic system in a superposition of 1 and 2\nψ = zeros(2)\nψ[1] = 1/sqrt(2)\nψ[2] = 1/sqrt(2)\n\nA = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ>|Vacuum>","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We then chose the observables that will be stored in the data and the MPSDynamics.runsim arguments. This example relies on the storage of the reduced density matrix (called reduceddensity in runsim).","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"\n#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\n\n#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H, prec=1E-4;\n                name = \"pure dephasing model with temperature\",\n                method = method,\n                obs = [ob1],\n                convobs = [ob1],\n                params = @LogParams(ΔE, N, d, α, s),\n                convparams = D,\n                reduceddensity=true,\n                verbose = false,\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"After having performed the dynamics, the analytical decoherence function is numerically calculated with the help of the quadgk function (from the QuadGK.jl package). It reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#----------\n# Analytical results at specified temperature \n# (see The Theory of Open Quantum System, H.-P. Breuer & F. Petruccione 2002, Chapter 4)\n#----------\n\nJohmic(ω,s) = (2*α*ω^s)/(ωc^(s-1))\n\ntime_analytical = LinRange(0.0,tfinal,Int(tfinal))\n\nΓohmic(t) = - quadgk(x -> Johmic(x,s)*(1 - cos(x*t))*coth(β*x/2)/x^2, 0, ωc)[1]\n\nDecoherence_ohmic(t) = 0.5*exp(Γohmic(t))","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Eventually, the stored reduced density matrix is compared against the analytical formula","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#-------------\n# Plots\n#------------\n\nρ12 = abs.(dat[\"data/Reduced ρ\"][1,2,:])\n\nplot(time_analytical, t->Decoherence_ohmic(t), label=\"Analytics\", title=L\"Pure Dephasing, Ohmic $s=%$s$, $\\beta = %$β ~\\mathrm{K}$\", linecolor=:black, xlabel=\"Time (arb. units)\", ylabel=L\"Coherence $|\\rho_{12}(t)|$\", linewidth=4, titlefontsize=16, legend=:best, legendfontsize=16, xguidefontsize=16, yguidefontsize=16, tickfontsize=10)\n\nplot!(dat[\"data/times\"], ρ12, lw=4, ls=:dash, label=\"Numerics\")","category":"page"},{"location":"examples/puredephasing/#Bibliography","page":"Pure-Dephasing","title":"Bibliography","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"[breuer]: Breuer, H.;Petruccione, F. The Theory of Open Quantum Systems; Oxford University Press, 2002.","category":"page"},{"location":"examples/anderson-model/#The-Anderson-Impurity-Model","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"Here we give some context on the examples provided in MPSDynamics/examples/anderson_model_double.jl and MPSDynamics/examples/anderson_model_interleaved.jl. In these two examples, we use the fermionic chain mapping proposed in [khon_efficient_2021] to show how to perform tensor network simulations of the Single Impurity Anderson Model (SIAM) with the MPSDynamics.jl library. ","category":"page"},{"location":"examples/anderson-model/#Basics-of-the-fermionic-chain-mapping","page":"The Anderson Impurity Model","title":"Basics of the fermionic chain mapping","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"Before giving the code implementation, a short recap on the problem statement and on the fermionic mapping used to solved it. The SIAM Hamiltonian is defined as:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    hat H^textSIAM  = hat H_textloc + hat H_texthyb + hat H_textcond = overbraceepsilon_d hat d^dagger hat d^hat H_textloc + underbracesum_k V_k Big( hat d^dagger hat c_k + hat c_k^dagger hat d Big)_H_texthyb + underbracesum_k epsilon_k hat c_k^dagger hat c_k_H_I^textchain","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"All of the operators obey to the usual fermionic anti-commutation relations: hat c_i hat c_j^dagger  = delta_ij, hat c_i hat c_j  =hat c_i^dagger hat c_j^dagger  =0 forall ij. The chain mapping is based on a thermofield-like transformation  [devega_thermo_2015], performed with fermions: ancillary fermionic operators hat c_2k are defined, one for each of the original fermionic modes hat c_1k. A Bogoliubov transformation is then applied, so that two new fermionic modes hat f_1k and hat f_2k are defined as a linear combination of hat c_1k and hat c_2k. Two chains are defined: the chain labelled 1 for the empty modes:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"hat f_1k=e^-iG  hat c_k e^iG= cosh(theta_k) hat c_1k -sinh(theta_k)  hat c_2k^dagger \nhat f_2k=e^-iG hat c_k e^iG= cosh(theta_k)  hat c_1k +sinh(theta_k)  hat c_2k^dagger","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We remark that this is the same Bogoliubov transformation used in the thermofield[devega_thermo_2015] for the bosonic case: the only thing that changes is a plus sign, that takes into account the fermionic anti-commutation relations. With these new fermionic operators we obtain the thermofield-transformed Hamiltonian, where the system interacts with two environments at zero temperature, allowing for pure state simulations (and thus the employement of MPS).","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The thermofield-transformed Hamiltonian is then mapped on two chains, defined and constructed using the TEDOPA chain mapping: the chain labelled 1 is for the empty modes, the chain labelled 2 for the filled modes. The following relations are used to define the functions equivalent to the spectral density of the bosonic case, one for each chain:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"beginaligned\n   V_1k = V_k sin theta_k = sqrtfrac1e^beta epsilon_k+1 \n   V_2k = V_k cos theta_k = sqrtfrac1e^-beta epsilon_k+1 \nendaligned","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"where we choose the spectral function that characterizes the fermionic bath to be: V_k= sqrt1-k^2, and we define the dispersion relation as: e_k = k, that is, a linear dispersion relation with propagation speed equal to 1. This latter choice corresponds to a model of metals (gapless energy spectrum). We select a filled state as the initial state of the defect. Using the mapping proposed in [1], the chain Hamiltonian becomes:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    beginaligned\n    hat H^textchain  = hat H_textloc + sum_i = 12bigg J_i0 Big(hat d^dagger hat a_i0 + hat d hat a_i0^dagger Big) +  + sum_n=1^infty  Big( J_in hat a_in^dagger hat a_in-1 +  J_in hat  a_in-1^dagger hat a_in Big) + sum_n=0^infty E_in hat  a_in^dagger hat a_in bigg\n    endaligned","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"where the J_in coefficients are the couplings between the chain sites and the E_in coefficients are the energies associated to each chain site. Clearly, the interactions are between nearest neighbors. This, combined with the fact that the fermions in our model are spinless, enables a straightforward mapping into fermionic operators of the bosonic creation and annihilation operators, that on their part obey to the bosonic commutation relations: hat b_i hat b_j^dagger = delta_ij, hat b_i hat b_j =hat b_i^dagger hat b_j^dagger =0 forall ij. The mapping derived from Jordan-Wigner transformations for spinless fermions is:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    hat a_i^dagger hat a_i+1 + hat a_i+1^dagger hat a_i = hat b_i^dagger hat b_i+1 + hat b_i+1^dagger hat b_i  ","category":"page"},{"location":"examples/anderson-model/#Double-chain-MPO","page":"The Anderson Impurity Model","title":"Double chain MPO","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"(Image: image)","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We can represent the Hamiltonian hat H^textchain as a MPOs bond dimension is: chi = 4. The MPO has the structure of a double chain, with an impurty site at the center, and therefore can be seen as the product of the following matrices:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    H = W_1N cdotcdot W_1 0 cdot W_d cdot W_20 cdot  cdot W_2 N  ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"where the matrices are defined as:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"beginaligned\n W_1N = \nbeginbmatrix\nhatmathbb I  J_2N hat b_2N^dagger  J_2N hat b_2N  E_2N hat b_2N^dagger hat b_2N \nendbmatrix quad   W_1 0 = \nbeginbmatrix\n hat mathbb I  J_20 hat b_20^dagger  J_20 hat b_20  E_20 hat b_20^dagger hat b_20\n0 0  0  hat b_20 \n0 0  0  hat b_20^dagger \n0 0  0  hatmathbb I\nendbmatrix \n W_d = \nbeginbmatrix\n hat mathbb I  hat d^dagger  hat d  epsilon_d hat d^dagger hat d\n0 0  0  hat d \n0 0  0  hat d^dagger \n0 0  0  hatmathbb I\nendbmatrix \n W_2 0 =\nbeginbmatrix\n hat mathbb I  hat b_10^dagger  hat b_10  E_10 hat b_10^dagger hat b_10\n0 0  0  hat J_10b_10 \n0 0  0  hat J_10b_10^dagger \n0 0  0  hatmathbb I\nendbmatrix\n quad W_2 N =\nbeginbmatrix\n E_2N hat b_2N^dagger hat b_2N  J_2N hat b_2N  J_2N hat b_2N^dagger  hatmathbb I\nendbmatrix\nendaligned","category":"page"},{"location":"examples/anderson-model/#Interleaved-chain-MPO","page":"The Anderson Impurity Model","title":"Interleaved chain MPO","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"(Image: image)","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The drawback of the double chain representation is that the particle-hole pairs are spatially separated in the MPS, creating correlations and therefore leading to a dramatic increase in the bond dimensions. This is why Kohn and Santoro propose an interleaved geometry, the advantages of which are thoroughly explained in [khon_eff_2022]. Exploiting the interleaved representation, the interaction comes to be between next-nearest neighbors: a string operator appears in the Jordan-Wigner transformation from bosons to fermions:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    hat a_i^dagger hat a_i+2 + hat a_i+2^dagger hat a_i = hat b_i^dagger hat F_i+1 hat b_i+2 + hat b_i hat F_i+1 hat b_i+2^dagger","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"where the string operator hat F_i is defined as: hat F_i = (-1)^hat n_i = hatmathbb I -2 hat n_i = hatmathbb I-2 hat b_i^dagger hat b_i.  It is possible to find the analytical form also for MPOs with long range interaction \\cite{mpo}. In the case of next-nearest neighbors interactions between spinless fermions, in the interleaved geometry of Fig. \\ref{subfig:folded}, the MPO representation will require a bond dimension chi=6. We explicitly write it as:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"    H = W_d cdot W_2 0 cdot W_1 0 cdotcdot W_2N cdot W_1 N  ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"where the matrices are defined as: ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"beginaligned\n W_d = \nbeginbmatrix\n hatmathbb I  hat d  hat d^dagger  0  0  E_d hat d^dagger hat d \nendbmatrix quad W_2 0 = \nbeginbmatrix\n hat mathbb I  hat b_20  hat b_20^dagger  0  0  E_20 hat b_20^dagger hat b_20\n0 0  0  hatF_20  0  J_20 hat b_20^dagger \n0 0  0  0  hatF_20  J_20 hat b_20 \n0 0  0  0  0   0\n0 0  0  0  0  0 \n0 0  0  0  0  hatmathbb I\nendbmatrix \n W_1 0 = \nbeginbmatrix\n hat mathbb I  hat b_10  hat b_10^dagger  0  0  E_10 hat b_10^dagger hat b_10\n0 0  0  hat F_10  0  0 \n0 0  0  0  hatF_10  0 \n0 0  0  0  0  J_10 hat b_10^dagger \n0 0  0  0  0  J_10 hat b_10 \n0 0  0  0  0  hatmathbb I\nendbmatrix \n W_2N = \nbeginbmatrix\n hat mathbb I  hat b_2N  hat b_2N^dagger  0  0  E_2N hat b_2N^dagger hat b_2N\n0 0  0  hatF_2N  0  0 \n0 0  0  0  hatF_2N  0 \n0 0  0  0  0  J_2N hat b_2N^dagger \n0 0  0  0  0  J_2N hat b_2N \n0 0  0  0  0  hatmathbb I\nendbmatrix \nquad W_1 N\nbeginbmatrix\n E_1N hat b_1N^dagger hat b_1N  0 0  J_1N hat b_1N^dagger  J_1N hat b_1N  hatmathbb I\nendbmatrix \nendaligned","category":"page"},{"location":"examples/anderson-model/#Code-implementation","page":"The Anderson Impurity Model","title":"Code implementation","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The fermionic mapping can be strightforwardly implemented with the methods of MPSDyanmics.jl. We provide two examples: ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"examples/anderson_model_double, simulating the SIAM with the double-chain geometry\nexamples/anderson_model_interleaved, simulating the SIAM with the interleaved-chain geometry","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"They only differ on the way the Hamiltonian MPO is defined. We now briefly review the important bits of the code.","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"Both of the examples start with the definition of the physical parameters,","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"N = 40      # number of chain sites\nβ = 10.0     # inverse temperature\nμ = 0.      # chemical potential\nEd = 0.3    # energy of the impurity\nϵd = Ed - μ # energy of the impurity minus the chemical potential","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The chaincoeffs_fermionic function is needed to compute the chain coefficients. It requires as inputs the number of modes of each chain N, the inverse temperature \\beta, a label to specify if the chain modes are empty (label is 1.0) or filled (label is 2.0), and both the dispersion relation epsilon_k and the fermionic spectral density funciton V_k.","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"function ϵ(x)\n    return x\nend\n\nfunction J(x)\n    return sqrt(1 - x^2) # semi-circular density of states\nend\n\nchainparams1 = chaincoeffs_fermionic(N, β, 1.0; ϵ, J, save=false) # empty\nchainparams2 = chaincoeffs_fermionic(N, β, 2.0; ϵ, J, save=false) # filled","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We then specify the simulation parameters","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"dt = 0.25           # time step\nT = 15.0            # simulation time\nmethod = :DTDVP     # time-evolution method\nDmax = 150          # MPS max bond dimension\nprec = 0.0001       # precision for the adaptive TDVP\n","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"and with this we are ready to construct the Hamiltonian MPO and specify the initial state, which will obviously differ depending on the chosen geometry.","category":"page"},{"location":"examples/anderson-model/#Double-chain-geometry","page":"The Anderson Impurity Model","title":"Double chain geometry","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The Hamiltonian is defined using the tightbinding_mpo function, which takes as an input the number of modes of each chain N, the defect's energy \\epsilon_d, and the chain coefficients of the first chainparams1 and second chainparams2 chain. The MPS for the initial state is a factorized state made of: N filled states, a filled impurity, and N empty states. ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"H = tightbinding_mpo(N, ϵd, chainparams1, chainparams2)\n\nψ =  unitcol(2,2) # (0,1) filled impurity state\nA = productstatemps(physdims(H), state=[fill(unitcol(2,2), N)..., ψ, fill(unitcol(1,2), N)...]) # MPS","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"To avoid the DTDVP algorithm from getting stuck in a local minimum, it is better to embed the MPS in a manifold of bond dimension 2 (or more):","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"mpsembed!(A, 2) # to embed the MPS in a manifold of bond dimension 2","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We can now define the observables for the two chains and for the impurity","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"ob1 = OneSiteObservable(\"chain1_filled_occup\", numb(2), (1,N))\nob2 = OneSiteObservable(\"chain2_empty_occup\", numb(2), (N+2, 2N+1))\nob3 = OneSiteObservable(\"system_occup\", numb(2), N+1)","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"and run the simulation","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"A, dat = runsim(dt, T, A, H;\n                name = \"Anderson impurity problem (folded chain)\",\n                method = method,\n                obs = [ob1, ob2, ob3], \n                convobs = [ob1],\n                params = @LogParams(N, ϵd, β, c1, c2),\n                convparams = [prec],   \n                Dlim = Dmax,          \n                savebonddims = true,   # we want to save the bond dimension\n                verbose = false,\n                save = false,\n                plot = true,\n                );","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"With very minimal post-processing of the data","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"# Reshaping the vector to a column matrix and horizontal concatenation\nsystem_occup_col = reshape(dat[\"data/system_occup\"], :, 1)\nocc = hcat(dat[\"data/chain1_filled_occup\"]', system_occup_col)\nocc = vcat(occ', dat[\"data/chain2_empty_occup\"])","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"we plot the results:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"# Plot the system occupation    \np1 = plot(\n    dat[\"data/times\"],\n    dat[\"data/system_occup\"],\n    xlabel = L\"$t$\",\n    ylabel = L\"$n_d$\",\n    title = \"System Occupation\",\n    size = (700, 500)\n)\n\n# Plot the occupation of the chain sites\np2 = heatmap(\n    collect(1:2*N+1),\n    dat[\"data/times\"],\n    transpose(occ),  # Use the matrix form\n    cmap = :coolwarm,\n    aspect_ratio = :auto,\n    xlabel = L\"$N_{i,j}$ chain sites\",\n    ylabel = L\"$t$\",\n    title = \"Chain Occupation\",\n    colorbar = true,\n    size = (700, 500)\n)\n\n# Plot the bond dimensions\np3 = heatmap(\n    collect(1:2*N+2),\n    dat[\"data/times\"],\n    transpose(dat[\"data/bonddims\"]),\n    cmap = :magma,\n    aspect_ratio = :auto,\n    xlabel = L\"$N_{i,j}$ chain sites\",\n    ylabel = L\"$t$\",\n    title = \"Bond Dimensions\",\n    colorbar = true,\n    size = (700, 500)\n)\n\n# Define indices for columns to be plotted\ncolumns_to_plot = [1, 5, 10, 15, 20]\n\n# Plot vertical slices for occupancy\np4 = plot(title = \"Chain occupation\")\nfor col in columns_to_plot\n    plot!(p4, occ[:, col], label = L\"$t =$\"*\"$col\", xlabel = L\"$N_{i,j}$ chain sites\", ylabel = \"chain occupation\")\nend\n\n# Plot vertical slices for bond dimensions\np5 = plot(title = \"Bond Dimensions\")\nfor col in columns_to_plot\n    plot!(p5, dat[\"data/bonddims\"][:, col], label = L\"$t =$\"*\"$col\", xlabel = L\"$N_{i,j}$ chain sites\", ylabel = L\"$\\chi$\")\nend\n\n# Display the plots\nplot(p2, p3, p4, p5, p1, layout = (3, 2), size = (1400, 1200))\n","category":"page"},{"location":"examples/anderson-model/#Interleaved-chain-geometry","page":"The Anderson Impurity Model","title":"Interleaved chain geometry","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The Hamiltonian is defined using the interleaved_tightbinding_mpo function, which takes as an input the number of modes of each chain N, the defect's energy \\epsilon_d, and the chain coefficients of the first chainparams1 and second chainparams2 chain. The MPS for the initial state is a factorized state (bond dimension 1) made of: a filled impurity, and 2N alternate filled-empty states. ","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"H = interleaved_tightbinding_mpo(N, ϵd, chainparams1, chainparams2)\n\nψ =  unitcol(2,2) # (0,1) filled impurity state\nTot = Any[]\npush!(Tot, ψ)\nfor i in 1:(N)\n    push!(Tot, unitcol(2,2))\n    push!(Tot, unitcol(1,2))\nend\n\nA = productstatemps(physdims(H), state=Tot) # MPS","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"To avoid the DTDVP algorithm from getting stuck in a local minimum, it is better to embed the MPS in a manifold of bond dimension 2 (or more):","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"mpsembed!(A, 2) # to embed the MPS in a manifold of bond dimension 2","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We can finally define the observables for the interleaved chain","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"ob1 = OneSiteObservable(\"system_occup\", numb(2), 1)\nob2 = OneSiteObservable(\"folded_chain_occup\", numb(2), (2,2N+1))","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"and run the simulation","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"A, dat = runsim(dt, T, A, H;\n                name = \"Anderson impurity problem (folded chain)\",\n                method = method,\n                obs = [ob1, ob2], \n                convobs = [ob1],\n                params = @LogParams(N, ϵd, β, c1, c2),\n                convparams = [prec],   \n                Dlim = Dmax,          \n                savebonddims = true,   # we want to save the bond dimension\n                verbose = false,\n                save = false,\n                plot = true,\n                );","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"To show the data in a clear way, we do a bit of post-processing of the data to unfold the chain, and move back to the double chain representation:","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"unfolded_occ = Vector{Vector{Float64}}()  # Assuming the elements are of type Float64\nunfolded_bonds = Vector{Vector{Float64}}()  # Adjust the type based on actual data\n\n# Populate unfolded_occ by iterating in the specific order mentioned\nfor i in 1:N  # Adjusted for 1-based indexing\n    push!(unfolded_occ, dat[ \"data/folded_chain_occup\"][2N + 1 - 2i, :])\nend\n\npush!(unfolded_occ, dat[\"data/folded_chain_occup\"][1,:])\n\nfor i in 2:N\n    push!(unfolded_occ, dat[\"data/folded_chain_occup\"][2i,:])\nend\n\n# Populate unfolded_bonds similarly\nfor i in 1:(N+1)  # Adjusted for 1-based indexing\n    push!(unfolded_bonds, dat[\"data/bonddims\"][2N + 3 - 2i,:])  # Assuming bonddims is directly accessible\nend\n\npush!(unfolded_bonds, dat[\"data/bonddims\"][1,:])\n\nfor i in 2:(N+1)\n    push!(unfolded_bonds, dat[\"data/bonddims\"][2i,:])\nend\n\nunfolded_bonds_matrix = hcat(unfolded_bonds...)'\nunfolded_occ_matrix = hcat(unfolded_occ...)'","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"We conclude by plotting the data","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"# Plot the system occupation    \np1 = plot(\n    dat[\"data/times\"],\n    dat[\"data/system_occup\"],\n    xlabel = L\"$t$\",\n    ylabel = L\"$n_d$\",\n    title = \"System Occupation\",\n    size = (700, 500)\n)\n\n# Plot the occupation of the chain sites\np2 = heatmap(\n    collect(1:2*N),\n    dat[\"data/times\"],\n    transpose(unfolded_occ_matrix),  # Use the matrix form\n    cmap = :coolwarm,\n    aspect_ratio = :auto,\n    xlabel = L\"$N_{i,j}$ chain sites\",\n    ylabel = L\"$t$\",\n    title = \"Chain Occupation\",\n    colorbar = true,\n    size = (700, 500)\n)\n\n# Plot the bond dimensions\np3 = heatmap(\n    collect(1:2*N+2),\n    dat[\"data/times\"],\n    transpose(unfolded_bonds_matrix),\n    cmap = :magma,\n    aspect_ratio = :auto,\n    xlabel = L\"$N_{i,j}$ chain sites\",\n    ylabel = L\"$t$\",\n    title = \"Bond Dimensions\",\n    colorbar = true,\n    size = (700, 500)\n)\n\n# Define indices for columns to be plotted\ncolumns_to_plot = [1, 5, 10, 15, 20]\n\n\n# Plot vertical slices for occupancy\np4 = plot(title = \"Chain occupation\")\nfor col in columns_to_plot\n    plot!(p4, unfolded_occ_matrix[:, col], label = L\"$t =$\"*\"$col\", xlabel = L\"$N_{i,j}$ chain sites\", ylabel = \"chain occupation\")\nend\n\n# Plot vertical slices for bond dimensions\np5 = plot(title = \"Bond Dimensions\")\nfor col in columns_to_plot\n    plot!(p5, unfolded_bonds_matrix[:, col], label = L\"$t =$\"*\"$col\", xlabel = L\"$N_{i,j}$ chain sites\", ylabel = L\"$\\chi$\")\nend\n\n# Display the plots\nplot(p2, p3, p4, p5, p1, layout = (3, 2), size = (1400, 1200))","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"________________","category":"page"},{"location":"examples/anderson-model/#References","page":"The Anderson Impurity Model","title":"References","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"[khon_efficient_2021]: Kohn, L.; Santoro, G. E. Efficient mapping for anderson impurity problems with matrix product states. Phys. Rev. B 2021, 104 (1), 014303. https://doi.org/10.1103/PhysRevB.104.014303.","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"[devega_thermo_2015]: de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"[khon_eff_2022]: Kohn L.; Santoro G. E. J. Stat. Mech. (2022) 063102 DOI 10.1088/1742-5468/ac729b.","category":"page"},{"location":"examples/sbm/#The-Spin-Boson-Model","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"","category":"section"},{"location":"examples/sbm/#Context","page":"The Spin-Boson Model","title":"Context","text":"","category":"section"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"The Spin-Boson Model (SBM) is a prototypical model in the theory of open quantum systems where a two level system interacts linearly with a bosonic bath","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"\thatH = fracomega_02hatsigma_z + Deltahatsigma_x + int_0^+inftyomega hata^dagger_omegahata_omega mathrmdomega + hatsigma_xint_0^+inftysqrtJ(omega)(hata_omega + hata^dagger_omega)mathrmdomega","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Even though this model is fairly simple it is physically very rich and it is not analytically solvable. For these reason it has become a test-bed for numerical methods simulating open quantum systems dynamics in the non-perturbative non-Markovian regime.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"For instance when the SD is Ohmic, this model presents a phase transition between a so called localised and a delocalised phase for alpha approx 12.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Here we break out and comment the script in MPSDynamics/examples/sbm_zero_temperature.jl to show how to simulate this model with an Ohmic SD (hard cut-off) using the T-TEDOPA method as implemented in MPSDynamics.jl.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"The T-TEDOPA method relies on a truncated chain mapping that transform the initial Hamiltonian into","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"\thatH = fracomega_02 hatsigma_z + Delta hatsigma_x + c_0 hatsigma_x(hatb_0^dagger + hatb_0) + sum_i=0^N-1 t_i (hatb_i+1^dagger hatb_i + mathrmhc) + sum_i=0^N-1 epsilon_i hatb_i^dagger hatb_i ","category":"page"},{"location":"examples/sbm/#The-code","page":"The Spin-Boson Model","title":"The code","text":"","category":"section"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"First a multi-line comment introduces the model and the aim of the script.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#=\n    Example of a zero-temperature Spin-Boson Model with an hard cut-off Ohmic spectral density J(ω) = 2αω when ω < ωc and 0 otherwise\n\n    The dynamics is simulated using the T-TEDOPA method that maps the normal modes environment into a non-uniform tight-binding chain.\n\n    H = \\\\frac{ω_0}{2} σ_z + Δ σ_x + c_0 σ_x(b_0^\\\\dagger + b_0) + \\\\sum_{i=0}^{N-1} t_i (b_{i+1}^\\\\dagger b_i +h.c.) + \\\\sum_{i=0}^{N-1} ϵ_i b_i^\\\\dagger b_i \n\n    Two variants of the one-site Time Dependent Variational Principal (TDVP) are presented for the time evolution of the quantum state.\n=#","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, and the LaTeXStrings.jl one to be able to use LaTeX in the plots.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"using MPSDynamics, Plots, LaTeXStrings","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We then define variables for the physical parameters of the simulation. Among these, two are convergence parameters:","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes \nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 6 # number of Fock states of the chain modes\n\nN = 30 # length of the chain\n\nα = 0.1 # coupling strength\n\nΔ = 0.0 # tunneling \n\nω0 = 0.2 # TLS gap\n\ns = 1 # ohmicity\n\ncpars = chaincoeffs_ohmic(N, α, s) # chain parameters, i.e. on-site energies ϵ_i, hopping energies t_i, and system-chain coupling c_0","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present two one-site implementation of TDVP that both preserves the unitarity of the evolution:","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D\nthe adaptive method with the keyword :DTDVP where the bond dimension is locally increased at each time step if the TDVP projection error crosses a threshold value","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Logically the constant bond dimension of the MPS for TDVP1 and the threshold of the projection error for DTDVP are their respective convergence parameter. ","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 0.5 # time step\n\ntfinal = 30.0 # simulation time\n\nmethod = :TDVP1 # Regular one-site TDVP (fixed bond dimension)\n\n# method = :DTDVP # Adaptive one-site TDVP (dynamically updating bond dimension)\n\nconvparams = [2,4,6] # MPS bond dimension (1TDVP)\n\n# convparams = [1e-2, 1e-3, 1e-4] # threshold value of the projection error (DTDVP)","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Using MPSDynamics.jl built-in methods we define the SBM MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\nH = spinbosonmpo(ω0, Δ, d, N, cpars) # MPO representation of the Hamiltonian\n\nψ = unitcol(1,2) # Initial up-z system state \n\nA = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ>|Vacuum>","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We then chose the observables that will be measured during the time evolution after being passed as an argument of the MPSDynamics.runsim method.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\nob2 = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))\n\nob3 = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We run the simulation from t = 0 to tfinal with time-steps of size dt using the method method. The convobs observables will be measured and stored for the convergence parameters convparams, whereas the obs observables will only be measured and stored for the most precise convergence parameter.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H;\n                name = \"ohmic spin boson model\",\n                method = method,\n                obs = [ob2,ob3],\n                convobs = [ob1],\n                params = @LogParams(N, d, α, Δ, ω0, s),\n                convparams = convparams,\n                verbose = false,\n                savebonddims = true, # this keyword argument enables the bond dimension at each time step to be saved when using DTDVP\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Finally, we plot the simulation results that are stored in the dat dictionnary.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#----------\n# Plots\n#----------\n\nmethod == :TDVP1 && plot(dat[\"data/times\"], dat[\"convdata/sz\"], label=[\"Dmax = 2\" \"Dmax = 4\" \"Dmax = 6\"], xlabel=L\"t\",ylabel=L\"\\sigma_z\")\n\nmethod == :DTDVP && plot(dat[\"data/times\"], dat[\"convdata/sz\"], label=[\"p = 1e-2\" \"p = 1e-3\" \"p = 1e-4\"], xlabel=L\"t\",ylabel=L\"\\sigma_z\") \n\nmethod == :DTDVP && heatmap(dat[\"data/times\"], collect(0:N+1), dat[\"data/bonddims\"], xlabel=L\"t\",ylabel=\"bond index\")\n\nheatmap(dat[\"data/times\"], collect(1:N), abs.(dat[\"data/SXdisp\"][1,:,:]), xlabel=L\"t\",ylabel=\"chain mode\")","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The MPSDynamics.jl package provides an easy to use interface for performing tensor network simulations on matrix product states (MPS) and tree tensor network (TTN) states. Written in the Julia programming language, MPSDynamics.jl is a versatile open-source package providing a choice of several variants of the Time-Dependent Variational Principle (TDVP) method for time evolution.  The package also provides strong support for the measurement of observables, as well as the storing and logging of data, which makes it a useful tool for the study of many-body physics.  The package has been developed with the aim of studying non-Markovian open system dynamics at finite temperature using the state-of-the-art numerically exact Thermalized-Time Evolving Density operator with Orthonormal Polynomials Algorithm (T-TEDOPA) based on environment chain mapping. However the methods implemented can equally be applied to other areas of physics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is currently undergoing massive restructurations/improvement. It's a work in progress until the next release scheduled for May, 2024.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package may be installed by typing the following into a Julia REPL","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    ] add https://github.com/shareloqs/MPSDynamics.git","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"user-guide.md\", \"examples/sbm.md\", \"examples/puredephasing.md\", \"examples/timedep.md\", \"examples/anderson-model.md\", \"examples/bath-observables.md\", \"theory.md\", \"methods.md\", \"dev.md\"]\nDepth = 3","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use the package in your research, please consider citing it. You can add the Zenodo record to your BibTex file:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{mpsdynamics_zenodo2021,\n\ttitle = {shareloqs/{MPSDynamics}},\n\tshorttitle = {{MPSDynamics.jl}},\n\turl = {https://zenodo.org/record/5106435},\n\tabstract = {Tensor network simulations for finite temperature, open quantum system dynamics},\n\tpublisher = {Zenodo},\n\tauthor = {Dunnett, Angus and Lacroix, Thibaut and Le Dé, Brieuc and Riva, Angela},\n\tyear = {2021},\n\tdoi = {10.5281/zenodo.5106435},\n}","category":"page"}]
}
