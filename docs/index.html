<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MPSDynamics.jl Documentation · MPSDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MPSDynamics.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>MPSDynamics.jl Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>MPSDynamics.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MPSDynamics.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="git@github.com:angusdunnett/MPSDynamics.git" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MPSDynamics.jl-Documentation"><a class="docs-heading-anchor" href="#MPSDynamics.jl-Documentation">MPSDynamics.jl Documentation</a><a id="MPSDynamics.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#MPSDynamics.jl-Documentation" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchild!-Tuple{MPSDynamics.Tree,Int64}" href="#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree,Int64}"><code>MPSDynamics.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchild!(tree::Tree, id::Int)</code></pre><p>Add child to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree,Int64,Int64}" href="#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree,Int64,Int64}"><code>MPSDynamics.addchildren!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchildren!(tree::Tree, id::Int, n::Int)</code></pre><p>Add <code>n</code> children to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chaincoeffs_ohmic-Tuple{Any,Any,Any}" href="#MPSDynamics.chaincoeffs_ohmic-Tuple{Any,Any,Any}"><code>MPSDynamics.chaincoeffs_ohmic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chaincoeffs_ohmic(nummodes, α, s, beta=&quot;inf&quot;; wc=1, soft=false)</code></pre><p>Generate chain coefficients for an Harmonic bath coupled to a spin-1/2 with spectral density given by: </p><p>soft cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s \exp(-ω/ω_c)$</span> </p><p>hard cutoff: <span>$J(ω) = 2παω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span></p><p>The Hamiltonian is given by:</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + σ_x\sum_kg_k(b_k^\dagger+b_k) + \sum_kω_kb_k^\dagger b_k$</span></p><p>And the spectral density is defined by:</p><p><span>$J(ω) ≡ π\sum_k|g_k|^2δ(ω-ω_k)$</span></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}" href="#MPSDynamics.chainmps-Tuple{Int64,Array{Int64,1},Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, sites::Vector{Int}, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal super-position over <code>sites</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}" href="#MPSDynamics.chainmps-Tuple{Int64,Int64,Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, site::Int, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations on <code>site</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainprop-Tuple{Any,Any}" href="#MPSDynamics.chainprop-Tuple{Any,Any}"><code>MPSDynamics.chainprop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainprop(t, cparams...)</code></pre><p>Propagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.dynamap-NTuple{4,Any}" href="#MPSDynamics.dynamap-NTuple{4,Any}"><code>MPSDynamics.dynamap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamap(ps1,ps2,ps3,ps4)</code></pre><p>Calulate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electron2kmps" href="#MPSDynamics.electron2kmps"><code>MPSDynamics.electron2kmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with 2 electrons in k-states <code>k1</code> and <code>k2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electronkmps" href="#MPSDynamics.electronkmps"><code>MPSDynamics.electronkmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS for an electron with momentum <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}" href="#MPSDynamics.elementmpo-Tuple{Any,Vararg{Any,N} where N}"><code>MPSDynamics.elementmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmpo(M, el...)</code></pre><p>Return the element of the MPO <code>M</code> for the set of physical states <code>el...</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}" href="#MPSDynamics.elementmps-Tuple{Any,Vararg{Any,N} where N}"><code>MPSDynamics.elementmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmps(A, el...)</code></pre><p>Return the element of the MPS <code>A</code> for the set of physical states <code>el...</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = chainmps(6, [2,4], 1);

julia&gt; elementmps(A, 1, 2, 1, 1, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 1, 1, 2, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 2, 1, 2, 1, 1)
0.0

julia&gt; elementmps(A, 1, 1, 1, 1, 1, 1)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.entanglemententropy-Tuple{Any}" href="#MPSDynamics.entanglemententropy-Tuple{Any}"><code>MPSDynamics.entanglemententropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">entanglemententropy(A)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchainlength-Tuple{Any,Any}" href="#MPSDynamics.findchainlength-Tuple{Any,Any}"><code>MPSDynamics.findchainlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchainlength(T, cparams...; eps=10^-6)</code></pre><p>Estimate length of chain required for a particular set of chain parameters by calulating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode,Int64}" href="#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode,Int64}"><code>MPSDynamics.findchild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchild(node::TreeNode, id::Int)</code></pre><p>Return integer corresponding to the which number child site <code>id</code> is of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any,OneSiteObservable}" href="#MPSDynamics.measure-Tuple{Any,OneSiteObservable}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(A, O; kwargs...)</code></pre><p>measure observable <code>O</code> on mps state <code>A</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}" href="#MPSDynamics.measure1siteoperator-Tuple{Array{T,1} where T,Any,Array{Int64,1}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A, O)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if i is specified.</p><p>For calculating operators on single sites this will be more efficient if the site is on the left of the mps.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}" href="#MPSDynamics.measure2siteoperator-Tuple{Array{T,1} where T,Any,Any,Int64,Int64}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure2siteoperator(A::Vector, M1, M2, j1, j2)</code></pre><p>Caculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal superposition of modes <code>k</code> of a bosonic tight-binding chain.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of mode <code>k</code> of a bosonic tight-binding chain. </p><p><code>chainparams</code> takes the form <code>[e::Vector, t::Vector]</code> where <code>e</code> are the on-site energies and <code>t</code> are the hoppping parameters.</p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}" href="#MPSDynamics.mpsembed!-Tuple{Array{T,1} where T,Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsembed(A::Vector, Dmax::Int)</code></pre><p>Embed MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code></p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsleftnorm!" href="#MPSDynamics.mpsleftnorm!"><code>MPSDynamics.mpsleftnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsleftnorm!(A::Vector, jq::Int=length(A))</code></pre><p>Left orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{Array{T,1} where T,Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::Vector, OC::Int)</code></pre><p>Put MPS <code>A</code> into mixed canonical form with orthogonality centre on site <code>OC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::TreeNetwork, id::Int)</code></pre><p>Normalise tree-MPS <code>A</code> such that orthogonality centre is on site <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsmoveoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmoveoc!(A::TreeNetwork, id::Int)</code></pre><p>Move the orthogonality centre of right normalised tree-MPS <code>A</code> to site <code>id</code>.</p><p>This function will be more efficient than using <code>mpsmixednorm!</code> if the tree-MPS is already right-normalised.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!" href="#MPSDynamics.mpsrightnorm!"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::Vector, jq::Int=1)</code></pre><p>Right orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::TreeNetwork)</code></pre><p>When applied to a tree-MPS, right normalise towards head-node.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork,Int64}" href="#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork,Int64}"><code>MPSDynamics.mpsshiftoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsshiftoc!(A::TreeNetwork, newhd::Int)</code></pre><p>Shift the orthogonality centre by one site, setting new head-node <code>newhd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{Array{T,1} where T}" href="#MPSDynamics.normmps-Tuple{Array{T,1} where T}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(A::Vector; mpsorthog=:None)</code></pre><p>Calculate norm of MPS <code>A</code>.</p><p>Setting <code>mpsorthog</code>=<code>:Right</code>/<code>:Left</code> will calculate the norm assuming right/left canonical form. Setting <code>mpsorthog=OC::Int</code> will cause the norm to be calculated assuming the orthoganility center is on site <code>OC</code>. If mpsorthog is <code>:None</code> the norm will be calculated as an MPS-MPS product.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(net::TreeNetwork; mpsorthog=:None)</code></pre><p>When applied to a tree-MPS <code>mpsorthog=:Left</code> is not defined.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}" href="#MPSDynamics.orthcentersmps-Tuple{Array{T,1} where T}"><code>MPSDynamics.orthcentersmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthcentersmps(A)</code></pre><p>Compute the orthoganality centres of MPS <code>A</code>.</p><p>Return value is a list in which each element is the corresponding site tensor of <code>A</code> with the orthoganility centre on that site. Assumes <code>A</code> is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{Array{T,1} where T}" href="#MPSDynamics.physdims-Tuple{Array{T,1} where T}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physdims(M)</code></pre><p>Return the physical dimensions of an MPS or MPO <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an <code>N</code>-site MPS with all local Hilbert space dimensions given by <code>d</code>. </p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provdided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p>The argument <code>mpsorthog</code> can be used to set the gauge of the resulting MPS.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randisometry-Tuple{Type,Int64,Int64}" href="#MPSDynamics.randisometry-Tuple{Type,Int64,Int64}"><code>MPSDynamics.randisometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randisometry([T=Float64], dims...)</code></pre><p>Construct a random isometry</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(tree::Tree, physdims, Dmax::Int, T::Type{&lt;:Number} = Float64)</code></pre><p>Construct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by <code>Dmax</code>.</p><p>The local Hilbert space dimensions are specified by physdims which can either be of type <code>Dims{length(tree)}</code>, specifying the dimension of each site, or of type <code>Int</code>, in which case the same local dimension is used for every site.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(N::Int, d::Int, Dmax::Int, T=Float64)</code></pre><p>Construct a random, <code>N</code>-site, right-normalised MPS with all local Hilbert space dimensions given by <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s131} where #s131&lt;:Number}} where N" href="#MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64,N}},Int64}, Tuple{Tuple{Vararg{Int64,N}},Int64,Type{#s131} where #s131&lt;:Number}} where N"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randmps(physdims::Dims{N}, Dmax::Int, T::Type{&lt;:Number} = Float64) where {N}</code></pre><p>Construct a random, right-normalised MPS with local Hilbert space dimensions given by <code>physdims</code> and max bond-dimension given by <code>Dmax</code>. </p><p><code>T</code> specifies the element type, eg. use <code>T=ComplexF64</code> for a complex valued MPS.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randtree-Tuple{Int64,Int64}" href="#MPSDynamics.randtree-Tuple{Int64,Int64}"><code>MPSDynamics.randtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randtree(numnodes::Int, maxdegree::Int)</code></pre><p>Construct a random tree with <code>nummodes</code> modes and max degree <code>maxdegree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.rmsd-Tuple{Any,Any}" href="#MPSDynamics.rmsd-Tuple{Any,Any}"><code>MPSDynamics.rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})</code></pre><p>Calculate the root mean squared difference between two measurements of an observable over the same time period.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdmps-Tuple{Any}" href="#MPSDynamics.svdmps-Tuple{Any}"><code>MPSDynamics.svdmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svdmps(A)</code></pre><p>For a right normalised mps <code>A</code> compute the full svd spectrum for a bipartition at every bond.</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdtrunc-Tuple{Any}" href="#MPSDynamics.svdtrunc-Tuple{Any}"><code>MPSDynamics.svdtrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)</code></pre><p>Perform a truncated SVD, with maximum number of singular values to keep equal to <code>truncdim</code> or truncating any singular values smaller than <code>truncerr</code>. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt</p></div><a class="docs-sourcelink" target="_blank" href="git@github.com:angusdunnett/MPSDynamics.git">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 18 January 2021 11:51">Monday 18 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
