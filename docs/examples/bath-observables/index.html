<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inspecting the bath by undoing the chain mapping · MPSDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">MPSDynamics.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../user-guide/">User Guide</a></li><li><a class="tocitem" href="../../nutshell/">MPSDynamics for open quantum systems in a nutshell</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../puredephasing/">Pure-Dephasing</a></li><li><a class="tocitem" href="../timedep/">Time-dependent Hamiltonian</a></li><li><a class="tocitem" href="../anderson-model/">The Anderson Impurity Model</a></li><li class="is-active"><a class="tocitem" href>Inspecting the bath by undoing the chain mapping</a><ul class="internal"><li><a class="tocitem" href="#The-code"><span>The code</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../theory/">Theoretical Background</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><a class="tocitem" href="../../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Inspecting the bath by undoing the chain mapping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inspecting the bath by undoing the chain mapping</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/shareloqs/MPSDynamics/blob/master/docs/src/examples/bath-observables.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Inspecting-the-bath-by-undoing-the-chain-mapping"><a class="docs-heading-anchor" href="#Inspecting-the-bath-by-undoing-the-chain-mapping">Inspecting the bath by undoing the chain mapping</a><a id="Inspecting-the-bath-by-undoing-the-chain-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Inspecting-the-bath-by-undoing-the-chain-mapping" title="Permalink"></a></h1><p>Here we give some context on the example script provided in <code>MPSDynamics/example/bath-observables.jl</code>. This example demonstrates the setup and execution of a simulation for a two-level system coupled to an Ohmic bath at finite temperature, where we exploit the access to the chain observables to:</p><ul><li>undo the chain mapping<sup class="footnote-reference"><a id="citeref-chin_exact_2010" href="#footnote-chin_exact_2010">[chin_exact_2010]</a></sup>, thus obtaining their representation in the extended bath of T-TEDOPA <sup class="footnote-reference"><a id="citeref-tamascelli_efficient_2019" href="#footnote-tamascelli_efficient_2019">[tamascelli_efficient_2019]</a></sup>, characterized by <span>$J(\omega, \beta)$</span></li><li>inverting the thermofield transformation<sup class="footnote-reference"><a id="citeref-devega_thermo_2015" href="#footnote-devega_thermo_2015">[devega_thermo_2015]</a></sup>, thus obtaining the representation of the physical frequencies in the original environment, characterized by <span>$J(\omega)$</span></li></ul><p>T-TEDOPA allows to substitute a thermally occupied bath by an extended one, in the pure state of the vacuum, extending the bath of frequencies to negative values: the <em>creation</em> from the system of a mode of <em>negative frequency</em> in the extended bath of frequencies corresponds to the <em>absorption</em> of energy for the system from the thermally occupied modes of the environment. However, by exploiting the thermofield transformation, it is possible to recover the picture of the occupations of the steady states in the physical bath of frequencies<sup class="footnote-reference"><a id="citeref-riva_thermal_2023" href="#footnote-riva_thermal_2023">[riva_thermal_2023]</a></sup>. </p><h2 id="The-code"><a class="docs-heading-anchor" href="#The-code">The code</a><a id="The-code-1"></a><a class="docs-heading-anchor-permalink" href="#The-code" title="Permalink"></a></h2><p>We start by defining the parameters of the simulation:</p><pre><code class="language-julia">d = 10      # number of Fock states of the chain modes
N = 60      # length of the chain
α = 0.01    # coupling strength
ω0 = 0.2  # TLS gap
s = 1       # ohmicity
ωc = 1.  # Cut-off of the spectral density J(ω)
β = 20    # Thermalized environment</code></pre><p>We set the specifics of the simulation:</p><pre><code class="language-julia">method = :TDVP1         # time-evolution method
conv = 3                # bond dimension for the TDVP1
dt = 0.5                # time step
tfinal = 60.0           # simulation time</code></pre><p>And then compute the chain coefficients, i.e. on-site energies <span>$\epsilon_i$</span>, hopping energies <span>$t_i$</span>, and system-chain coupling <span>$c_0$</span>, that define the chain representation of the pure-dephasing model:</p><pre><code class="language-julia">cpars = chaincoeffs_finiteT(N, β; α=α, s=s, J=nothing, ωc=ωc, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=false)</code></pre><p>with this, we can compute the corresponding MPO, and the initial state in MPS form (<span>$1/\sqrt{2}(|0\rangle + |1\rangle)$</span>):</p><pre><code class="language-julia">H = puredephasingmpo(ω0, d, N, cpars)

ψ = zeros(2)
ψ[1] = 1/sqrt(2)
ψ[2] = 1/sqrt(2)

A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...])</code></pre><p>We can now define the observables we are interested in computing. Importantly, we not only compute observables related to the system, but also to the chain modes, so that we can inspect the environment.</p><pre><code class="language-julia">ob1 = OneSiteObservable(&quot;sz&quot;, sz, 1)
ob2 = OneSiteObservable(&quot;sx&quot;, sx, 1)
ob3 = OneSiteObservable(&quot;chain_mode_occupation&quot;, numb(d), (2,N+1))
ob4 = OneSiteObservable(&quot;c&quot;, crea(d), collect(2:N+1))
ob5 = OneSiteObservable(&quot;cdag&quot;, crea(d), collect(2:N+1))
ob6 = TwoSiteObservable(&quot;cdagc&quot;, crea(d), anih(d), collect(2:N+1), collect(2:N+1))
ob7 = TwoSiteObservable(&quot;cdagcdag&quot;, crea(d), crea(d), collect(2:N+1), collect(2:N+1))
ob8 = TwoSiteObservable(&quot;cc&quot;, anih(d), anih(d), collect(2:N+1), collect(2:N+1))</code></pre><p>with this we run the simulation:</p><pre><code class="language-julia">A, dat = runsim(dt, tfinal, A, H, prec=1E-4;
                name = &quot;Bath observables in the pure dephasing model&quot;,
                method = method,
                obs = [ob1, ob2, ob3, ob4, ob5, ob6, ob7, ob8],
                convobs = [ob1],
                params = @LogParams(ω0, N, d, α, s, ψ),
                convparams = conv,
                reduceddensity = true,
                verbose = false,
                save = false,
                plot = true,
                );</code></pre><p>After the simulation, we need to post-process the data a bit, in order to map the correlations from the chain representation to the original environment. We start by defining the matrices associated to the mean values of <span>$c$</span> and <span>$c^\dagger$</span>:</p><pre><code class="language-julia">T = length(dat[&quot;data/times&quot;])

constr = Array{ComplexF64}(undef, N, N, T)
destr = Array{ComplexF64}(undef, N, N, T)
for t in 1:T
    constr[:,:,t] = diagm(0 =&gt; dat[&quot;data/cdag&quot;][:,t])
    destr[:,:,t] = diagm(0 =&gt; dat[&quot;data/c&quot;][:,t])
end</code></pre><p>During a numerical simulation we work with chain of finite length <span>$N$</span>. This truncation on chain modes, introduces a sampling on the modes in the original star-like environment. To recover the frequency modes that are implicitly sampled, one has to diagonalize the tri-diagonal <span>$N\times N$</span> matrix <span>$H^\text{chain}$</span>, where the diagonal is formed by the <span>$e_n$</span> coefficients, that is the chain&#39;s frequencies, and the upper and lower diagonals by the <span>$N-1$</span> hopping coefficients <span>$t_n$</span>. The unitary matrix that defines the change of basis from the star-like to the chain-like environment is <span>$U_n$</span>, constituted by the eigenvectors of <span>$H^\text{chain}$</span>. In the code, we use the <code>eigenchain</code> function:</p><pre><code class="language-julia">omeg = eigenchain(cpars, nummodes=N).values</code></pre><p>At each time step of the simulation, a number of one-site and two-sites observables where evaluated on the chain. To obtain their value in the extended bath of T-tedopa, characterized by <span>$J(\omega,\beta)$</span>, the unitary transformation that maps the extended bath Hamiltonian into the chain representation has to be reversed. For instance, when measuring the single site <span>$\hat n^c_i=\hat c_i^\dagger \hat c_i$</span> occupation number, we are not measuring the occupation number of the bosonic mode associated to the <span>$\omega_i$</span> frequency, but the occupation number of the <span>$i-$</span>th chain mode. Therefore to calculate the number of modes of the environment associated to a specific frequency <span>$\omega_i$</span>, the mapping must be reversed, to obtain the diagonal representation of the bosonic number operator:</p><p class="math-container">\[\begin{aligned}
\hat n^b_{i} = \hat b_i^\dagger \hat b_i = \sum_{k,l} U_{ik}^* \hat c_k^\dagger \hat c_l U_{li}.  
\end{aligned}\]</p><p>This is done in the code using the <code>measuremodes(X, cpars[1], cpars[2])</code> function, which outputs the vector of the diagonal elements of the operators, in the following way:</p><pre><code class="language-julia">bath_occup = mapslices(X -&gt; measuremodes(X, cpars[1], cpars[2]), dat[&quot;data/cdagc&quot;], dims = [1,2])
cdag_average = mapslices(X -&gt; measuremodes(X, cpars[1], cpars[2]), constr, dims = [1,2])
c_average = mapslices(X -&gt; measuremodes(X, cpars[1], cpars[2]), destr, dims = [1,2])</code></pre><p>To compute the correlators, we need the full matrix in the original basis. We therefore use the <code>measurecorrs</code> function:</p><pre><code class="language-julia">cc_average = mapslices(X -&gt; measurecorrs(X, cpars[1], cpars[2]), dat[&quot;data/cc&quot;], dims = [1,2])
cdagcdag_average = mapslices(X -&gt; measurecorrs(X, cpars[1], cpars[2]), dat[&quot;data/cdagcdag&quot;], dims = [1,2])

correlations_c = [
    cc_average[i, j, t] - c_average[i, 1, t] .* c_average[j, 1, t]
    for i in 1:size(cc_average, 1), j in 1:size(cc_average, 2), t in 1:size(cc_average, 3)
]
correlations_cdag = [
    cdagcdag_average[i, j, t] - cdag_average[i, 1, t] .* cdag_average[j, 1, t]
    for i in 1:size(cdagcdag_average, 1), j in 1:size(cdagcdag_average, 2), t in 1:size(cdagcdag_average,3)
]</code></pre><p>It is possible to invert the thermofield transformation (details in <sup class="footnote-reference"><a id="citeref-riva_thermal_2023" href="#footnote-riva_thermal_2023">[riva_thermal_2023]</a></sup>). The expression of the mean value of the number operator for the physical modes can be expressed as a function of mean values in the extended bath, which we denote <span>$\langle \hat a_{2k}^\dagger \hat a_{2k} \rangle$</span>:</p><p class="math-container">\[\begin{aligned}
    \langle \hat b_k^\dagger \hat b_k \rangle = \cosh{\theta_k}\sinh{\theta_k} (\langle \hat a_{2k}\hat a_{1k}\rangle + \langle \hat a_{1k}^\dagger\hat a_{2k}^\dagger\rangle ) + \sinh^2{\theta_k} (1+ \langle \hat a_{2k}^\dagger \hat a_{2k} \rangle ) ++ \cosh^2{\theta_k} \langle \hat a_{1k}^\dagger \hat a_{1k} \rangle
\end{aligned}\]</p><p>We remark that in the thermofield case, a negative frequency <span>$\omega_{2k}$</span> is associated to each positive frequency <span>$\omega_{1k}$</span>. The sampling is therefore symmetric around zero. This marks a difference with T-TEDOPA, where the sampling of frequencies was obtained through the thermalized measure <span>$d\mu(\beta) = \sqrt{J(\omega, \beta)}d\omega$</span>, and was not symmetric. To recover the results for the physical bath of frequencies starting from the results of our simulations, that were conducted using the T-TEDOPA chain mapping, we need to do an extrapolation for all of the mean values, in order to have their values for each <span>$\omega$</span> at <span>$-\omega$</span> as well. This is done in the code with the <code>physical_occup</code> function:</p><pre><code class="language-julia">bath_occup_phys = physical_occup(correlations_cdag[:,:,T], correlations_c[:,:,T], omeg, bath_occup[:,:,T], β, N)</code></pre><p>Finally, in the pure dephasing case, it is also possible to obtain the analytical prediction of the time evolution of the occupations of the bath&#39;s modes, so that we can compare our numerical results with the analytical ones, exploiting the Heisenberg time evolution relation:</p><p class="math-container">\[\begin{aligned}
\frac{d \langle \hat b_\omega \rangle}{dt} = -i \langle[ \hat b_\omega, \hat H] \rangle = - i \omega \langle\hat b_\omega \rangle - i \frac{\langle \hat \sigma_x \rangle}{2} \sqrt{J(\omega, \beta)},     \\
\frac{d \langle \hat n_\omega \rangle}{dt} = -i \langle[\hat b_\omega^\dagger \hat b_\omega, \hat H] \rangle= 2 \frac{|J(\omega,\beta)|}{\omega} \sin(\omega t).
\end{aligned}\]</p><p>To this end, it is convenient to choose one of the eigenstates of <span>$\hat \sigma_z$</span> as the initial state, so that <span>$\langle \hat \sigma_x \rangle = \pm 1$</span>. By solving these differential equations, one obtains the time evolved theoretical behavior of the bath. We define the function for the comparison with analytical predictions:</p><pre><code class="language-julia">Johmic(ω,s) = (2*α*ω^s)/(ωc^(s-1))

time_analytical = LinRange(0.0, tfinal, Int(tfinal))

Γohmic(t) = - quadgk(x -&gt; Johmic(x,s)*(1 - cos(x*t))*coth(β*x/2)/x^2, 0, ωc)[1]

Decoherence_ohmic(t) = 0.5 * exp(Γohmic(t))


α_theo = 0.25 * α
function Jtherm(x)
    if 1 &gt;= x &gt;= 0
        return +α_theo * abs(x)^s * (1 + coth(β*0.5*x))
    elseif -1 &lt;= x &lt;= 0
        return -α_theo * abs(x)^s * (1 + coth(β*0.5*x))
    else
        return 0
    end
end

bath_occup_analytical(ω, t) = abs(Jtherm(ω))/(ω^2)*2*(1-cos(ω*t)) </code></pre><p>We conclude the example by plotting.</p><pre><code class="language-julia">ρ12 = abs.(dat[&quot;data/Reduced ρ&quot;][1,2,:])

p1 = plot(time_analytical, t-&gt;Decoherence_ohmic(t), label=&quot;Analytics&quot;, title=L&quot;Pure Dephasing, Ohmic $s=%$s$, $\beta = %$β ~\mathrm{K}$&quot;, linecolor=:black, xlabel=&quot;Time (arb. units)&quot;, ylabel=L&quot;Coherence $|\rho_{12}(t)|$&quot;, linewidth=4, titlefontsize=16, legend=:best, legendfontsize=16, xguidefontsize=16, yguidefontsize=16, tickfontsize=10)
p1 = plot!(dat[&quot;data/times&quot;], ρ12, lw=4, ls=:dash, label=&quot;Numerics&quot;)

cumul = [bath_occup_analytical(omeg[i], tfinal)*(omeg[i+1]-omeg[i]) for i in 1:(length(omeg)-1)]

p2 = plot(omeg[1:length(omeg)-1], cumul, lw = 4, linecolor=:black,
             xlabel=L&quot;\omega&quot;, ylabel=L&quot;\langle n^b_\omega \rangle&quot;, label=&quot;Analytics&quot;,
             title=&quot;Mode occupation in the extended bath&quot;)
p2 = plot!(omeg, bath_occup[:, :, T], lw=4, ls=:dash, label=&quot;Numerics&quot;)

p3 = heatmap(omeg, omeg, abs.(real.(correlations_cdag[:,:,T]) .+ im*imag.(correlations_cdag[:,:,T])), 
            xlabel=L&quot;\omega&quot;,
            ylabel=L&quot;\omega&quot;, title=&quot;Environmental correlations&quot;)


Mhalf = Int(length(omeg)*0.5)+1
M = length(omeg)

p4 = plot(omeg[Mhalf:M], bath_occup_phys, lw=4,
            xlabel=L&quot;\omega&quot;, ylabel=L&quot;\langle n^b_\omega \rangle&quot;,
            title=&quot;Mode occupation in the physical bath&quot;)

plot(p1, p2, p3, p4, layout = (2, 2), size = (1400, 1200))</code></pre><p>___________________</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-chin_exact_2010"><a class="tag is-link" href="#citeref-chin_exact_2010">chin_exact_2010</a><blockquote><p>Chin, A. W.; Rivas, Á.; Huelga, S. F.; Plenio, M. B. Exact Mapping between System-Reservoir Quantum Models and Semi-Infinite Discrete Chains Using Orthogonal Polynomials. Journal of Mathematical Physics 2010, 51 (9), 092109. https://doi.org/10.1063/1.3490188.</p></blockquote></li><li class="footnote" id="footnote-tamascelli_efficient_2019"><a class="tag is-link" href="#citeref-tamascelli_efficient_2019">tamascelli_efficient_2019</a><blockquote><p>Tamascelli, D.; Smirne, A.; Lim, J.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Finite-Temperature Open Quantum Systems. Phys. Rev. Lett. 2019, 123 (9), 090402. https://doi.org/10.1103/PhysRevLett.123.090402.</p></blockquote></li><li class="footnote" id="footnote-devega_thermo_2015"><a class="tag is-link" href="#citeref-devega_thermo_2015">devega_thermo_2015</a><blockquote><p>de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.</p></blockquote></li><li class="footnote" id="footnote-riva_thermal_2023"><a class="tag is-link" href="#citeref-riva_thermal_2023">riva_thermal_2023</a><blockquote><p>Riva, A.; Tamascelli, D.; Dunnett, A. J.; Chin, A. W. Thermal cycle and polaron formation in structured bosonic environments. Phys. Rev. B 2023, 108, 195138, https://doi.org/10.1103/PhysRevB.108.195138.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../anderson-model/">« The Anderson Impurity Model</a><a class="docs-footer-nextpage" href="../../theory/">Theoretical Background »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 16 May 2024 10:23">Thursday 16 May 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
